<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2022-08-23 Tue 18:45 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>再谈 new/delete/malloc/free</title>
<meta name="author" content="DESKTOP-ZHJ" />
<meta name="description" content="Keep It Simple, Stupid" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="/static/site.css"/>
<script>
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
// @license-end
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">再谈 new/delete/malloc/free</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#缘由">1. 缘由</a></li>
<li><a href="#newdeletemallocfree-基本知识">2. new/delete/malloc/free 基本知识</a></li>
<li><a href="#追踪溯源">3. 追踪溯源</a>
<ul>
<li><a href="#内置类型">3.1. 内置类型</a></li>
<li><a href="#单个类对象">3.2. 单个类对象</a></li>
<li><a href="#类对象数组">3.3. 类对象数组</a></li>
</ul>
</li>
<li><a href="#总结">4. 总结</a></li>
</ul>
</div>
</div>

<div id="outline-container-缘由" class="outline-2">
<h2 id="缘由"><span class="section-number-2">1.</span> 缘由</h2>
<div class="outline-text-2" id="text-缘由">
<p>
从一开始搞 <code>C/C++</code> 的时候，一直在时不时的探究 <code>new/delete &amp;&amp; malloc/free</code> 几者之间的关系。没有一本书确切的，深入的探讨它们的具体机制。
只是零星的从一些书，一些博客中有所涉及。比如：《Effective C++》。本想题目标为"深入浅出 xxx"，后来想了一下有些夸大了，嘻嘻。
</p>

<p>
促使我写这篇文章的原因包括两个主要方面：
</p>

<p>
<b>其一</b>
</p>

<p>
在公司代码中遇到过 <code>new[] -&gt; delete</code> 这样的用法(也包括 <code>std::auto_ptr</code> 传入数组指针)。大家认为对于内置类型这样用没有问题，也不会导致内存泄漏。
我对此表示怀疑，并且进行了探究(查资料，发帖提问)。兴许不会导致内存泄漏，但是这样用是不合法的，可能会导致未定义的行为。
我个人觉得这个问题比较关键(很简单的问题，大家可能没有意识到)，于是在公司内部的 redmine 上发帖阐述，目的其实特别简单，就是那样不太好，
建议 <code>new[]&lt;-&gt;delete[]</code> 配对使用，而且也没有多少工作量。
</p>

<p>
有几个同学的评论，我很受用：
</p>

<p>
牛总：
</p>

<blockquote>
<p>
用 <code>new[]</code> 申请，如果用 <code>delete</code> 而不用 <code>delete[]</code> 释放的话，行为可能不止是泄露（可能的一种），我记得行为是不确定
（泄露，崩溃，越界，其他乱七八糟的问题）。
</p>

<p>
这是我10多年前学的某通信公司的编程规范，技术应该不会发生翻天覆地的变化吧？
</p>

<p>
BTW，这些问题最基本的静态工具都能扫描出来，如果是看代码出来的，那我们的程序只能祈祷上帝了&#x2026;
</p>
</blockquote>

<p>
丁亮：
</p>

<blockquote>
<p>
C programmers who migrate to C++ are often surprised to learn about
the delete vs. delete[] split. In C, it doesn't matter whether you're
allocating a single object using malloc()(here "object" is used in its
wider sense of course, i.e., a chunk of memory) or an array of objects
using calloc() &#x2014; when you destroy those objects, you call free() and
that's it. However, this superficial observation isn't fair. The
dynamic allocation functions of standard C know nothing about class
objects' semantics; they merely allocate chunks of raw memory. In C++,
new and its array counterpart new[] do more than this: in addition to
allocating raw storage, new and new[] initialize the allocated
object(s) by invoking their constructor(s). In a similar vein, delete
and delete[] don't just reclaim raw memory; they are also responsible
for invoking the destructor(s) of the allocated objects.
</p>
</blockquote>

<p>
寒辉：
</p>

<blockquote>
<p>
如果对于 int/char（自身不会再进一步申请资源，管理资源）这类的内置类型，new[] 和 delete 匹配使用是可以的，
我没有去找直接的证据（stdc++之类的实现证据），但是示例代码证明不存在资源泄露。想一想 c 中 malloc 和 free 匹配使用时，
它们从来就没有考虑过释放的资源是数组还是单个对象，不是吗？。我所见过的自行设计内存管理的软件代码是在申请实际大小内存之外再额外
加上一个整数大小的空间(一般就在返回指针地址的前面四个字节)，记录这个申请是多大的内存。释放时根据这个size将内存返还到内存管理链表中。
</p>

<p>
<code>new/delete</code> 对比 <code>malloc/free</code> ，有多一项的任务就是在申请（释放）内存后（前）构建（销毁）对象，在构建/销毁函数中往往涉及进一步申请/释放资源。
如果对这类对象的内存管理，不能做到匹配调用，则不能保证对象自身管理的资源是否正确使用，我想所谓的不确定行为就表现在这里。
至于调用构建函数前和销毁函数后，那块内存就是一块内存（荒草地），根据其大小申请内存或者释放即可。
</p>

<p>
我所见到的静态工具检查出来的不匹配，多是 int/char 之类动态申请的数组，我们想办法让它们匹配使用就是了。
这样做最直接的好处就是真的问题不会掩盖在那些伪问题里面，对我们代码质量的提高是有好处的。
</p>
</blockquote>

<p>
<b>其二</b>
</p>

<p>
请看代码：
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #5317ac;">class</span> <span style="color: #005a5f;">data_stream</span>
<span style="color: #000000;">{</span>
<span style="color: #5317ac;">public</span>:

     <span style="color: #721045;">data_stream</span><span style="color: #a8007f;">()</span> <span style="color: #a8007f;">{</span>
         c_ = <span style="color: #2544bb;">'a'</span>;
         i_ = 0;
         f_ = 0.0f;
         d_ = 0.0;
     <span style="color: #a8007f;">}</span>

     ~<span style="color: #721045;">data_stream</span><span style="color: #a8007f;">()</span> <span style="color: #a8007f;">{</span>
     <span style="color: #a8007f;">}</span>

 <span style="color: #5317ac;">private</span>:
     <span style="color: #005a5f;">char</span> <span style="color: #00538b;">c_</span>;
     <span style="color: #005a5f;">int</span> <span style="color: #00538b;">i_</span>;
     <span style="color: #005a5f;">float</span> <span style="color: #00538b;">f_</span>;
     <span style="color: #005a5f;">double</span> <span style="color: #00538b;">d_</span>;
 <span style="color: #000000;">}</span>;

 <span style="color: #5317ac;">class</span> <span style="color: #005a5f;">stream_buffer</span>
 <span style="color: #000000;">{</span>
 <span style="color: #5317ac;">public</span>:
     <span style="color: #721045;">stream_buffer</span><span style="color: #a8007f;">(</span><span style="color: #005a5f;">char</span> * <span style="color: #00538b;">buffer</span><span style="color: #a8007f;">)</span> <span style="color: #a8007f;">{</span>
         buffer_ = buffer;
     <span style="color: #a8007f;">}</span>

     ~<span style="color: #721045;">stream_buffer</span><span style="color: #a8007f;">()</span> <span style="color: #a8007f;">{</span>
         <span style="color: #5317ac;">if</span> <span style="color: #005f88;">(</span>buffer_<span style="color: #005f88;">)</span> <span style="color: #005f88;">{</span>
             <span style="color: #5317ac;">delete</span> <span style="color: #904200;">[]</span> buffer_;
         <span style="color: #005f88;">}</span>
     <span style="color: #a8007f;">}</span>

 <span style="color: #5317ac;">private</span>:
     <span style="color: #005a5f;">char</span> *<span style="color: #00538b;">buffer_</span>;
 <span style="color: #000000;">}</span>;


 <span style="color: #005a5f;">int</span> <span style="color: #721045;">main</span><span style="color: #000000;">()</span>
 <span style="color: #000000;">{</span>
     <span style="color: #005a5f;">data_stream</span> *<span style="color: #00538b;">ds</span> = <span style="color: #5317ac;">new</span> <span style="color: #005a5f;">data_stream</span><span style="color: #a8007f;">()</span>;
     <span style="color: #005a5f;">stream_buffer</span> <span style="color: #00538b;">sb</span><span style="color: #a8007f;">(</span><span style="color: #5317ac;">reinterpret_cast</span><span style="color: #005f88;">&lt;</span><span style="color: #005a5f;">char</span>*<span style="color: #005f88;">&gt;(</span>ds<span style="color: #005f88;">)</span><span style="color: #a8007f;">)</span>;

     <span style="color: #5317ac;">return</span> 0;
 <span style="color: #000000;">}</span>
</pre>
</div>

<p>
两个问题：
</p>

<ol class="org-ol">
<li>会不会导致内存泄漏 ?</li>
<li>合不合法 ?</li>
<li>基于这两个原因，我打算深入的探究一下原因。</li>
</ol>
</div>
</div>

<div id="outline-container-newdeletemallocfree-基本知识" class="outline-2">
<h2 id="newdeletemallocfree-基本知识"><span class="section-number-2">2.</span> new/delete/malloc/free 基本知识</h2>
<div class="outline-text-2" id="text-newdeletemallocfree-基本知识">
<p>
<b>new/delete 流程</b>
</p>

<ol class="org-ol">
<li>operator new (size_t size)</li>
<li>malloc(size)</li>
<li>new operator 构造函数</li>
<li>返回指针</li>
</ol>

<p>
delete 与之相似，先调用该对象的析构函数，然后调用 free 来释放 size 大小的内存块。于是我们可以这样使用：
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #005a5f;">void</span>* <span style="color: #5317ac;">operator</span> <span style="color: #5317ac;">new</span><span style="color: #000000;">(</span><span style="color: #005a5f;">size_t</span> <span style="color: #00538b;">size</span><span style="color: #000000;">)</span> <span style="color: #5317ac;">throw</span><span style="color: #000000;">(</span><span style="color: #0000c0;">std</span>::<span style="color: #005a5f;">bad_alloc</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
    <span style="color: #0000c0;">std</span>::cout &lt;&lt; <span style="color: #2544bb;">"in operator new | alloc size: "</span> &lt;&lt; size &lt;&lt; <span style="color: #0000c0;">std</span>::endl;
    <span style="color: #005a5f;">void</span> * <span style="color: #00538b;">p</span> = malloc<span style="color: #a8007f;">(</span>size<span style="color: #a8007f;">)</span>;

    <span style="color: #5317ac;">return</span> p;
<span style="color: #000000;">}</span>

<span style="color: #005a5f;">void</span> <span style="color: #5317ac;">operator</span> <span style="color: #5317ac;">delete</span><span style="color: #000000;">(</span><span style="color: #005a5f;">void</span> *<span style="color: #00538b;">pointer</span><span style="color: #000000;">)</span>
<span style="color: #000000;">{</span>
    <span style="color: #0000c0;">std</span>::cout &lt;&lt; <span style="color: #2544bb;">"operator delete "</span> &lt;&lt; <span style="color: #0000c0;">std</span>::endl;
    free<span style="color: #a8007f;">(</span>pointer<span style="color: #a8007f;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #5317ac;">class</span> <span style="color: #005a5f;">data_stream</span>
<span style="color: #000000;">{</span>
<span style="color: #5317ac;">public</span>:
    <span style="color: #721045;">data_stream</span><span style="color: #a8007f;">()</span> <span style="color: #a8007f;">{</span>
        <span style="color: #0000c0;">std</span>::cout &lt;&lt; <span style="color: #2544bb;">"in data_stream ctor"</span> &lt;&lt;  <span style="color: #0000c0;">std</span>::endl;
    <span style="color: #a8007f;">}</span>

    ~<span style="color: #721045;">data_stream</span><span style="color: #a8007f;">()</span> <span style="color: #a8007f;">{</span>
        <span style="color: #0000c0;">std</span>::cout &lt;&lt; <span style="color: #2544bb;">"in data_stream dtor "</span> &lt;&lt; <span style="color: #0000c0;">std</span>::endl;
    <span style="color: #a8007f;">}</span>

<span style="color: #5317ac;">private</span>:
    <span style="color: #005a5f;">char</span> <span style="color: #00538b;">c_</span>;
    <span style="color: #005a5f;">int</span> <span style="color: #00538b;">i_</span>;
    <span style="color: #005a5f;">float</span> <span style="color: #00538b;">f_</span>;
    <span style="color: #005a5f;">double</span> <span style="color: #00538b;">d_</span>;
<span style="color: #000000;">}</span>;

<span style="color: #005a5f;">int</span> <span style="color: #721045;">main</span><span style="color: #000000;">()</span>
<span style="color: #000000;">{</span>
    <span style="color: #005a5f;">data_stream</span> *<span style="color: #00538b;">ds</span> = <span style="color: #5317ac;">new</span> <span style="color: #005a5f;">data_stream</span><span style="color: #a8007f;">()</span>;
    <span style="color: #5317ac;">delete</span> ds;

    <span style="color: #5317ac;">return</span> 0;
<span style="color: #000000;">}</span>
</pre>
</div>

<p>
输出为：
</p>

<pre class="example">
in operator new | alloc size: 24
in data_stream ctor
in data_stream dtor
operator delete
</pre>

<p>
我们还可以这么用：
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #005a5f;">void</span> *<span style="color: #00538b;">p</span> = malloc<span style="color: #000000;">(</span><span style="color: #5317ac;">sizeof</span><span style="color: #a8007f;">(</span>data_stream<span style="color: #a8007f;">)</span><span style="color: #000000;">)</span>;
<span style="color: #005a5f;">data_stream</span> *<span style="color: #00538b;">ds</span>  = <span style="color: #5317ac;">new</span><span style="color: #000000;">(</span>p<span style="color: #000000;">)</span> <span style="color: #005a5f;">data_stream</span><span style="color: #000000;">()</span>;
<span style="color: #5317ac;">delete</span> ds;
</pre>
</div>

<p>
又或者直接用栈内存：
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #005a5f;">char</span> <span style="color: #00538b;">buff</span><span style="color: #000000;">[</span><span style="color: #5317ac;">sizeof</span><span style="color: #a8007f;">(</span>data_stream<span style="color: #a8007f;">)</span><span style="color: #000000;">]</span>;
<span style="color: #005a5f;">data_stream</span> *<span style="color: #00538b;">ds</span> = <span style="color: #5317ac;">new</span><span style="color: #000000;">(</span>buff<span style="color: #000000;">)</span> <span style="color: #005a5f;">data_stream</span><span style="color: #000000;">()</span>;
ds-&gt;~data_stream<span style="color: #000000;">()</span>;
</pre>
</div>

<p>
<code>new[]/delete[]</code> 流程:
</p>

<ol class="org-ol">
<li><code>operator[](size_t size)</code> size 为整个数组大小</li>
<li><code>malloc(size)</code> 申请 size 大小的空间</li>
<li>分别调用构造函数</li>
<li>返回指针</li>
</ol>

<p>
delete[] 与之相似，先分别调用每个数组对象的析构函数，然后用 free 释放大小为 size 的内存块。
</p>

<p>
验证例子：
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #005a5f;">void</span>* <span style="color: #5317ac;">operator</span> <span style="color: #5317ac;">new</span><span style="color: #000000;">(</span><span style="color: #005a5f;">size_t</span> <span style="color: #00538b;">size</span><span style="color: #000000;">)</span> <span style="color: #5317ac;">throw</span><span style="color: #000000;">(</span><span style="color: #0000c0;">std</span>::<span style="color: #005a5f;">bad_alloc</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
    <span style="color: #0000c0;">std</span>::cout &lt;&lt; <span style="color: #2544bb;">"in operator new | alloc size: "</span> &lt;&lt; size &lt;&lt; <span style="color: #0000c0;">std</span>::endl;
    <span style="color: #005a5f;">void</span> * <span style="color: #00538b;">p</span> = malloc<span style="color: #a8007f;">(</span>size<span style="color: #a8007f;">)</span>;

    <span style="color: #5317ac;">return</span> p;
<span style="color: #000000;">}</span>

<span style="color: #005a5f;">void</span>* <span style="color: #5317ac;">operator</span> <span style="color: #5317ac;">new</span><span style="color: #000000;">[](</span><span style="color: #005a5f;">size_t</span> <span style="color: #00538b;">size</span><span style="color: #000000;">)</span> <span style="color: #5317ac;">throw</span><span style="color: #000000;">(</span><span style="color: #0000c0;">std</span>::<span style="color: #005a5f;">bad_alloc</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
    <span style="color: #0000c0;">std</span>::cout &lt;&lt; <span style="color: #813e00;">"</span><span style="color: #2544bb;">in operator new[] | alloc size: &lt;&lt; size &lt;&lt; std::endl;</span>
    <span style="color: #005a5f;">void</span> * p = malloc<span style="color: #a8007f;">(</span>size<span style="color: #a8007f;">)</span>;

    <span style="color: #5317ac;">return</span> p;
<span style="color: #000000;">}</span>

<span style="color: #005a5f;">void</span> <span style="color: #5317ac;">operator</span> <span style="color: #5317ac;">delete</span><span style="color: #000000;">(</span><span style="color: #005a5f;">void</span> *<span style="color: #00538b;">pointer</span><span style="color: #000000;">)</span>
<span style="color: #000000;">{</span>
    <span style="color: #0000c0;">std</span>::cout &lt;&lt; <span style="color: #2544bb;">"operator delete "</span> &lt;&lt;  <span style="color: #0000c0;">std</span>::endl;
    free<span style="color: #a8007f;">(</span>pointer<span style="color: #a8007f;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #005a5f;">void</span> <span style="color: #5317ac;">operator</span> <span style="color: #5317ac;">delete</span><span style="color: #000000;">[](</span><span style="color: #005a5f;">void</span> *<span style="color: #00538b;">pointer</span><span style="color: #000000;">)</span>
<span style="color: #000000;">{</span>
    <span style="color: #0000c0;">std</span>::cout &lt;&lt; <span style="color: #2544bb;">"operator delete[] "</span> &lt;&lt; <span style="color: #0000c0;">std</span>::endl;
    free<span style="color: #a8007f;">(</span>pointer<span style="color: #a8007f;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #5317ac;">class</span> <span style="color: #005a5f;">data_stream</span>
<span style="color: #000000;">{</span>
<span style="color: #5317ac;">public</span>:
    <span style="color: #721045;">data_stream</span><span style="color: #a8007f;">()</span> <span style="color: #a8007f;">{</span>
        <span style="color: #0000c0;">std</span>::cout &lt;&lt; <span style="color: #2544bb;">"in data_stream ctor"</span> &lt;&lt;  <span style="color: #0000c0;">std</span>::endl;
    <span style="color: #a8007f;">}</span>

    ~<span style="color: #721045;">data_stream</span><span style="color: #a8007f;">()</span> <span style="color: #a8007f;">{</span>
        <span style="color: #0000c0;">std</span>::cout  &lt;&lt; <span style="color: #2544bb;">"in data_stream dtor"</span> &lt;&lt; <span style="color: #0000c0;">std</span>::endl;
    <span style="color: #a8007f;">}</span>
<span style="color: #000000;">}</span>;

<span style="color: #005a5f;">int</span> <span style="color: #721045;">main</span><span style="color: #000000;">()</span>
<span style="color: #000000;">{</span>
    <span style="color: #005a5f;">data_stream</span> *<span style="color: #00538b;">ds_array</span> = <span style="color: #5317ac;">new</span> <span style="color: #005a5f;">data_stream</span><span style="color: #a8007f;">[</span>3<span style="color: #a8007f;">]</span>;

    <span style="color: #5317ac;">delete</span><span style="color: #a8007f;">[]</span> ds_array;

    <span style="color: #5317ac;">return</span> 0;
<span style="color: #000000;">}</span>
</pre>
</div>

<p>
输出：
</p>

<pre class="example">
in operator new[] | alloc size: 76
in data_stream ctor
in data_stream ctor
in data_stream ctor
in data_stream dtor
in data_stream dtor
in data_stream dtor
operator delete[]
</pre>

<p>
一旦我们这样调用时：
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #005a5f;">data_stream</span> *<span style="color: #00538b;">ds_array</span> = <span style="color: #5317ac;">new</span> <span style="color: #005a5f;">data_stream</span><span style="color: #000000;">[</span>3<span style="color: #000000;">]</span>;

<span style="color: #5317ac;">delete</span> ds_array;
</pre>
</div>

<p>
输出：
</p>

<pre class="example">
in operator new[] | alloc size: 7
in data_stream ctor
in data_stream ctor
in data_stream ctor
in data_stream dtor
operator delete
</pre>

<p>
并发生了崩溃（为什么会崩溃？稍后详细分析）。
</p>

<p>
可是当我们使用内置类型(build-in)的时候：
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #005a5f;">int</span> *<span style="color: #00538b;">int_array</span> = <span style="color: #5317ac;">new</span> <span style="color: #005a5f;">int</span><span style="color: #000000;">[</span>3<span style="color: #000000;">]</span>;
<span style="color: #5317ac;">delete</span> int_array;
</pre>
</div>

<p>
输出：
</p>

<pre class="example">
in operator new[] | alloc size: 12
operator delete
</pre>

<p>
没有任何问题；
</p>

<p>
综上：
</p>

<ul class="org-ul">
<li>new(new[]) 和 delete(delete[]) 实质上都是调用 malloc 和 free。</li>
<li>malloc 的时候我们传入了大小，free 的时候并没有告诉编译器我需要释放的内存大小，编译器如何知道它应该释放多少空间呢？</li>
<li>为什么内置类型 =new[]-&gt;delete =没问题，而类对象发生了崩溃呢？</li>
</ul>

<p>
我想到了寒辉曾经跟我说的，编译器一定在某个地方记录了内存申请的大小，new 和 delete 只是多了一个调用析构函数的步骤。
但是，编译器记录的不仅仅是这些，否则，怎么解释 <code>new[]-&gt;delete</code> 对于类对象崩溃呢？大不了就内存泄漏啊！
</p>
</div>
</div>

<div id="outline-container-追踪溯源" class="outline-2">
<h2 id="追踪溯源"><span class="section-number-2">3.</span> 追踪溯源</h2>
<div class="outline-text-2" id="text-追踪溯源">
<p>
抱着上面的疑问，我进行了测试和跟踪。本想把分析过程分享一下的，可是分析过程描述会很杂乱，而且很容易让大家摸不着重点，就直接分享结论了。
</p>

<p>
编译器把可用内存分成了块，然后用一个双线链表把所有的块连接起来(malloc中调用编译器提供的内存分配函数)。
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a0132f;">#define</span> <span style="color: #00538b;">nNoMansLandSize</span> 4

<span style="color: #5317ac;">typedef</span> <span style="color: #5317ac;">struct</span> <span style="color: #005a5f;">_CrtMemBlockHeader</span>
<span style="color: #000000;">{</span>
        <span style="color: #5317ac;">struct</span> <span style="color: #005a5f;">_CrtMemBlockHeader</span> * <span style="color: #00538b;">pBlockHeaderNext</span>;
        <span style="color: #5317ac;">struct</span> <span style="color: #005a5f;">_CrtMemBlockHeader</span> * <span style="color: #00538b;">pBlockHeaderPrev</span>;
        <span style="color: #005a5f;">char</span> *                      <span style="color: #00538b;">szFileName</span>;
        <span style="color: #005a5f;">int</span>                         <span style="color: #00538b;">nLine</span>;
<span style="color: #a0132f;">#ifdef</span> _WIN64
        <span style="color: #505050;">/* </span><span style="color: #505050;">These items are reversed on Win64 to eliminate gaps in the struct</span>
<span style="color: #505050;">         * and ensure that sizeof(struct)%16 == 0, so 16-byte alignment is</span>
<span style="color: #505050;">         * maintained in the debug heap.</span>
<span style="color: #505050;">         */</span>
        <span style="color: #005a5f;">int</span>                         <span style="color: #00538b;">nBlockUse</span>;
        <span style="color: #005a5f;">size_t</span>                      <span style="color: #00538b;">nDataSize</span>;
<span style="color: #a0132f;">#else</span>  <span style="color: #505050;">/* </span><span style="color: #505050;">_WIN64</span><span style="color: #505050;"> */</span>
        <span style="color: #005a5f;">size_t</span>                      <span style="color: #00538b;">nDataSize</span>;
        <span style="color: #005a5f;">int</span>                         <span style="color: #00538b;">nBlockUse</span>;
<span style="color: #a0132f;">#endif</span>  <span style="color: #505050;">/* </span><span style="color: #505050;">_WIN64</span><span style="color: #505050;"> */</span>
        <span style="color: #005a5f;">long</span>                        <span style="color: #00538b;">lRequest</span>;
        <span style="color: #005a5f;">unsigned</span> <span style="color: #005a5f;">char</span>               <span style="color: #00538b;">gap</span><span style="color: #a8007f;">[</span>nNoMansLandSize<span style="color: #a8007f;">]</span>;
        <span style="color: #505050;">/* </span><span style="color: #505050;">followed by:</span>
<span style="color: #505050;">         *  unsigned char           data[nDataSize];</span>
<span style="color: #505050;">         *  unsigned char           anotherGap[nNoMansLandSize];</span>
<span style="color: #505050;">         */</span>
<span style="color: #000000;">}</span> <span style="color: #005a5f;">_CrtMemBlockHeader</span>;

-----------------

Type of block:

<span style="color: #a0132f;">#define</span> <span style="color: #00538b;">_FREE_BLOCK</span>      0
<span style="color: #a0132f;">#define</span> <span style="color: #00538b;">_NORMAL_BLOCK</span>    1
<span style="color: #a0132f;">#define</span> <span style="color: #00538b;">_CRT_BLOCK</span>       2
<span style="color: #a0132f;">#define</span> <span style="color: #00538b;">_IGNORE_BLOCK</span>    3
<span style="color: #a0132f;">#define</span> <span style="color: #00538b;">_CLIENT_BLOCK</span>    4
<span style="color: #a0132f;">#define</span> <span style="color: #00538b;">_MAX_BLOCKS</span>      5
</pre>
</div>
</div>

<div id="outline-container-内置类型" class="outline-3">
<h3 id="内置类型"><span class="section-number-3">3.1.</span> 内置类型</h3>
<div class="outline-text-3" id="text-内置类型">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #005a5f;">int</span> *<span style="color: #00538b;">int_array</span> = <span style="color: #5317ac;">new</span> <span style="color: #005a5f;">int</span><span style="color: #000000;">[</span>16<span style="color: #000000;">]</span>;
<span style="color: #5317ac;">delete</span> <span style="color: #000000;">[]</span> int_array;
</pre>
</div>

<p>
我测试的时候： <code>int_array</code> 首地址为 <code>0x004E4DF8</code> 。所在的内存块为：
</p>

<pre class="example">
0x004E4DC8  00 00 00 00 00 00 00 00 9a 0e 3e 17 a9 a5 00 1c  ........?.&amp;gt;.??..
0x004E4DD8  c0 47 4e 00 00 00 00 00 00 00 00 00 00 00 00 00  ?GN.............
0x004E4DE8  40 00 00 00 01 00 00 00 a0 00 00 00 fd fd fd fd  @.......?...????
-&gt; nDataSize(size_t:4)，值为 0x40，即: 用户申请了 64 字节内存
-&gt; nBlockUse(int:4)，值为 0x01 ，即: _NORMAL_BLOCK(A call to malloc or calloc creates a Normal block. )
-&gt; lRequest(long:4), 值为 0xa0 , 即：请求号为 10
-&gt; 四字节 gap, 值为 0xfdfdfdfd. fd -&gt; "Fence Memory" 荒芜区
0x004E4DF8  cd cd cd cd cd cd cd cd cd cd cd cd cd cd cd cd  ???????????????? -&gt; 用户内存
0x004E4E08  cd cd cd cd cd cd cd cd cd cd cd cd cd cd cd cd  ???????????????? -&gt; 用户内存
0x004E4E18  cd cd cd cd cd cd cd cd cd cd cd cd cd cd cd cd  ???????????????? -&gt; 用户内存
0x004E4E28  cd cd cd cd cd cd cd cd cd cd cd cd cd cd cd cd  ???????????????? -&gt; 用户内存
0x004E4E38  fd fd fd fd ab ab ab ab ab ab ab ab ee fe ee fe  ????????????????
-&gt; 四字节的gap: 0xfdfdfdfd 表示结束。备注:用户内存使用两个四字节的 gap 包围起来。
</pre>

<p>
这也就解释了为什么编译器会知道我们申请了多大空间，释放空间的时候，我们只需要提供释放内存的首地址，编译器可以推算出我们申请了多大的空间，
进而进行了释放(所谓释放就是链表节点删除，当然还有一些重置操作)。
</p>
</div>
</div>

<div id="outline-container-单个类对象" class="outline-3">
<h3 id="单个类对象"><span class="section-number-3">3.2.</span> 单个类对象</h3>
<div class="outline-text-3" id="text-单个类对象">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #5317ac;">class</span> <span style="color: #005a5f;">data_stream</span>
<span style="color: #000000;">{</span>
<span style="color: #5317ac;">public</span>:
    <span style="color: #721045;">data_stream</span><span style="color: #a8007f;">()</span> <span style="color: #a8007f;">{</span>
        <span style="color: #0000c0;">std</span>::cout &lt;&lt; <span style="color: #2544bb;">"in data_stream ctor"</span> &lt;&lt;  <span style="color: #0000c0;">std</span>::endl;
    <span style="color: #a8007f;">}</span>

    ~<span style="color: #721045;">data_stream</span><span style="color: #a8007f;">()</span> <span style="color: #a8007f;">{</span>
        <span style="color: #0000c0;">std</span>::cout &lt;&lt; <span style="color: #2544bb;">"in data_stream dtor"</span> &lt;&lt; <span style="color: #0000c0;">std</span>::endl;
    <span style="color: #a8007f;">}</span>
<span style="color: #5317ac;">private</span>:
    <span style="color: #005a5f;">int</span> <span style="color: #00538b;">i</span>;
    <span style="color: #005a5f;">float</span> <span style="color: #00538b;">f</span>;
    <span style="color: #005a5f;">double</span> <span style="color: #00538b;">d</span>;
<span style="color: #000000;">}</span>;

<span style="color: #005a5f;">data_stream</span> *<span style="color: #00538b;">ds_array</span> = <span style="color: #5317ac;">new</span> <span style="color: #005a5f;">data_stream</span><span style="color: #000000;">()</span>;
<span style="color: #5317ac;">delete</span> ds_array;
</pre>
</div>

<p>
分析：
</p>

<pre class="example">
0x00A54DE8  10 00 00 00 01 00 00 00 a0 00 00 00 fd fd fd fd  ........?...????
-&gt; nDatasize(size_t:4) 0x10 即: 16 个字节(int+float+double)
0x00A54DF8  cd cd cd cd cd cd cd cd cd cd cd cd cd cd cd cd  ???????????????? -&gt; 用户内存
</pre>
</div>
</div>

<div id="outline-container-类对象数组" class="outline-3">
<h3 id="类对象数组"><span class="section-number-3">3.3.</span> 类对象数组</h3>
<div class="outline-text-3" id="text-类对象数组">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #005a5f;">void</span>* <span style="color: #5317ac;">operator</span> <span style="color: #5317ac;">new</span><span style="color: #000000;">[](</span><span style="color: #005a5f;">size_t</span> <span style="color: #00538b;">size</span><span style="color: #000000;">)</span> <span style="color: #5317ac;">throw</span><span style="color: #000000;">(</span><span style="color: #0000c0;">std</span>::<span style="color: #005a5f;">bad_alloc</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
    <span style="color: #0000c0;">std</span>::cout &lt;&lt; <span style="color: #2544bb;">"in operator new[] | alloc size: "</span> &lt;&lt; size &lt;&lt; <span style="color: #0000c0;">std</span>::endl;
    <span style="color: #005a5f;">void</span> * <span style="color: #00538b;">p</span> = malloc<span style="color: #a8007f;">(</span>size<span style="color: #a8007f;">)</span>;

    <span style="color: #5317ac;">return</span> p;
<span style="color: #000000;">}</span>

<span style="color: #5317ac;">class</span> <span style="color: #005a5f;">data_stream</span>
<span style="color: #000000;">{</span>
<span style="color: #5317ac;">public</span>:
    <span style="color: #721045;">data_stream</span><span style="color: #a8007f;">()</span> <span style="color: #a8007f;">{</span>
        <span style="color: #0000c0;">std</span>::cout &lt;&lt; <span style="color: #2544bb;">"in data_stream ctor"</span> &lt;&lt; <span style="color: #0000c0;">std</span>::endl;
    <span style="color: #a8007f;">}</span>

    ~<span style="color: #721045;">data_stream</span><span style="color: #a8007f;">()</span> <span style="color: #a8007f;">{</span>
        <span style="color: #0000c0;">std</span>::cout &lt;&lt; <span style="color: #2544bb;">"in data_stream dtor"</span> &lt;&lt; <span style="color: #0000c0;">std</span>::endl;
    <span style="color: #a8007f;">}</span>
<span style="color: #5317ac;">private</span>:
    <span style="color: #005a5f;">int</span> <span style="color: #00538b;">i</span>;
<span style="color: #000000;">}</span>;

<span style="color: #005a5f;">data_stream</span> *<span style="color: #00538b;">ds_array</span> = <span style="color: #5317ac;">new</span> <span style="color: #005a5f;">data_stream</span><span style="color: #000000;">[</span>4<span style="color: #000000;">]</span>;
<span style="color: #5317ac;">delete</span> <span style="color: #000000;">[]</span>ds_array;
</pre>
</div>

<p>
类对象数组和普通的类对象有所差别，我分两步进行分析：
</p>

<p>
第一步：=operator new[](size_t size)=
</p>

<p>
从 <code>p</code> 的地址开始：
</p>

<pre class="example">
0x00204DE8  14 00 00 00 01 00 00 00 a0 00 00 00 fd fd fd fd  ........?...????
-&gt; nDatasize(size_t:4) 0x14 即：20 个字节
0x00204DF8  cd cd cd cd cd cd cd cd cd cd cd cd cd cd cd cd  ???????????????? -&gt; 用户内存
0x00204E08  cd cd cd cd fd fd fd fd ab ab ab ab ab ab ab ab  ????????????????
</pre>

<p>
纳尼？不应该是 16 个字节么？怎么多了 4 个字节？ 继续往下看。
</p>

<p>
第二步: <code>data_stream *ds_array = new data_stream[4];</code> 中的 <code>ds_array</code> 值
</p>

<pre class="example">
0x00204DDC  00 00 00 00 00 00 00 00 00 00 00 00 14 00 00 00  ................
0x00204DEC  01 00 00 00 a0 00 00 00 fd fd fd fd 04 00 00 00  ....?...????....
-&gt; nDatasize(size_t:4) 向前偏移了四个字节
-&gt; 多余的四个字节是 0x04 即 4，也就是数组的长度。
0x00204DFC  cd cd cd cd cd cd cd cd cd cd cd cd cd cd cd cd  ????????????????
0x00204E0C  fd fd fd fd ab ab ab ab ab ab ab ab 00 00 00 00  ????????????....
</pre>

<p>
注意，原因来了！ <code>ds_array</code> 的地址是 <code>0x00204DFC</code> 而不是 <code>operator new[]</code> 中返回的内存地址 <code>0x00204DF8</code> 。
只是向后偏移了 4 个字节。多余的四个字节用来存储数组的长度。
</p>

<p>
推测(无事实依据)：申请完内存后，是编译器把数组的大小放到前四个字节，并向后偏移了 4 个字节，进行我们所看到的指针(<code>data_stream</code>)赋值。
这个偏移操作 malloc 并不知道(对赋值操作反汇编以后，你可以看到执行构造函数时的地址偏移，以及赋值时的偏移。)，malloc 所知道的内存是包括这四个字节的，
也就是他申请了 20 个字节，到时候释放 20 个字节。而当调用 <code>delete[]</code> 的时候，先把指针偏移回去，回到 <code>free</code> 所能理解的格式。
这样数组的大小对于 <code>malloc/free</code> 就是黑盒操作。
</p>

<p>
好了，现在我们来解释 <code>new[]-&gt;delete</code> 一个对象数组为什么是会崩溃。 <code>new[]/delete[]</code> 会有一个向前/向后偏移四个字节的操作，当 <code>new[]</code> 之后，
用 delete 并没有进行指针的偏移，直接把对应数据进行类型转换成 <code>_CrtMemBlockHeader</code> ，因此转换之后的 <code>_CrtMemBlockHeader</code> 变量都是无效的，
进而 <code>free</code> 内存崩溃。
</p>
</div>
</div>
</div>

<div id="outline-container-总结" class="outline-2">
<h2 id="总结"><span class="section-number-2">4.</span> 总结</h2>
<div class="outline-text-2" id="text-总结">
<ol class="org-ol">
<li>对于内置类型，=new[]-&gt;= 怎么对应都不会有问题， <code>free</code> 只需要一个首地址，通过指针偏移可以获取到下一个内存块和上一个内存的地址，
把这个内存块从链表中删除就 ok 了。</li>
<li>对于类对象数组，赋值过程中编译器做了一些 free 层面不知道的偏移，所以一旦 <code>new[]</code> 和 <code>delete[]</code> 不对应，会发生崩溃。</li>
</ol>

<p>
这只是从技术层面去分析机制，不代表分析没问题就可以滥用，况且这只是针对 VS2010，不同的编译器应该会有不同的实现方式。
</p>

<p>
为了保证跨平台不会出问题，强烈建议大家还是老老实实的去找好对应关系 <code>malloc-&gt;free</code>, <code>new-&gt;delete</code>, <code>new[]-&gt;delete[]</code> 。遵循标准来，不要投机取巧。
</p>

<p>
btw:
</p>

<ol class="org-ol">
<li>其实，分析过程是有漏洞的，我发现内存块与 <code>_CrtMemBlockHeader</code> 不能完全对应上，原因没有深究.</li>
<li>推荐 <a href="http://www.codeguru.com/cpp/w-p/win32/tutorials/article.php/c9535/Inside-CRT-Debug-Heap-Management.htm">inside CRT: Debug Heap Management</a>，经常用 VS 调试的童鞋看了之后会非常有感触的，灰常奈斯一个帖子。</li>
</ol>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="postamble">First created: 2013-07-28 00:00:00 <br />Last updated: 2022-08-23 Tue 18:22 <br />Power by <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.1 (<a href="https://orgmode.org">Org</a> mode 9.4.4)</p>
</div>
</body>
</html>
