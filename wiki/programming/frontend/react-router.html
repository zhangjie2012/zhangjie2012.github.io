<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-08-23 Tue 18:44 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>React Router</title>
<meta name="author" content="DESKTOP-ZHJ" />
<meta name="description" content="Keep It Simple, Stupid" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="/static/site.css" />
<script>
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
// @license-end
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">React Router</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org00b468e">1. 指南</a>
<ul>
<li><a href="#org0243e1a">1.1. 主要组件</a>
<ul>
<li><a href="#org57f5204">1.1.1. 路由器</a></li>
<li><a href="#orgb73c5e7">1.1.2. 路由匹配</a></li>
<li><a href="#org336989e">1.1.3. 路由变更（Nav）</a></li>
</ul>
</li>
<li><a href="#orga177d55">1.2. <span class="todo TODO">TODO</span> 服务端渲染（Server Rendering）</a></li>
<li><a href="#org44bd374">1.3. 代码拆分（Code Splitting）</a></li>
<li><a href="#org7949e56">1.4. 滚动恢复</a>
<ul>
<li><a href="#org30143cc">1.4.1. 滚动到顶部</a></li>
<li><a href="#org2cfbbb8">1.4.2. 通用的解决方案</a></li>
</ul>
</li>
<li><a href="#org21e7f86">1.5. 原理</a>
<ul>
<li><a href="#org4b5758f">1.5.1. 静态路由</a></li>
<li><a href="#org63b897e">1.5.2. 动态路由</a></li>
<li><a href="#org1fa49bd">1.5.3. 嵌套路由</a></li>
<li><a href="#orgda5c459">1.5.4. 响应式路由</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd86f912">2. API</a>
<ul>
<li><a href="#org1a113d4">2.1. Hooks</a></li>
<li><a href="#orgd27420c">2.2. <code>&lt;BrowserRouter&gt;</code></a></li>
<li><a href="#org33c9375">2.3. <code>&lt;HashRouter&gt;</code></a></li>
<li><a href="#org9742f83">2.4. <code>&lt;Link&gt;</code></a></li>
<li><a href="#orgacdfed4">2.5. <code>&lt;NavLink&gt;</code></a></li>
<li><a href="#org3a8bcec">2.6. <code>&lt;MemoryRouter&gt;</code></a></li>
<li><a href="#org657f18f">2.7. <code>&lt;Redirect&gt;</code></a></li>
<li><a href="#orgf78d2a6">2.8. <code>&lt;Route&gt;</code></a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<a href="https://reacttraining.com/react-router/web/guides/quick-start">react-router</a>
</p>

<div id="outline-container-org00b468e" class="outline-2">
<h2 id="org00b468e"><span class="section-number-2">1.</span> 指南</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org0243e1a" class="outline-3">
<h3 id="org0243e1a"><span class="section-number-3">1.1.</span> 主要组件</h3>
<div class="outline-text-3" id="text-1-1">
<p>
React Router 主要分三类组件：
</p>

<ul class="org-ul">
<li>路由器（routers），比如 <code>&lt;BrowserRouter&gt;</code> 和 <code>&lt;HashRouter&gt;</code></li>
<li>路由匹配，比如 <code>&lt;Route&gt;</code> 和 <code>&lt;Switch&gt;</code></li>
<li>导航（Navigation），比如 <code>&lt;Link&gt;</code>, <code>&lt;NavLink&gt;</code> 和 <code>&lt;Redirect&gt;</code> ，也成为路由变更</li>
</ul>

<p>
所有的组件，都需要从 <code>react-router-dom</code> 库中导入。
</p>
</div>

<div id="outline-container-org57f5204" class="outline-4">
<h4 id="org57f5204"><span class="section-number-4">1.1.1.</span> 路由器</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
路由组件的核心是 React Router，对于 Web 项目， <code>react-router-dom</code> 提供了 <code>&lt;BrowserRouter&gt;</code> 和 <code>&lt;HashRouter&gt;</code> 两种 routers。
主要区别在于他们存储 URL 和与服务器通信的方式。
</p>

<ul class="org-ul">
<li><code>&lt;BrowserRouter&gt;</code> 使用正常的 URL 路径，要求正确的配置服务器地址</li>
<li><code>&lt;HashRouter&gt;</code> 讲当前的路径存储再 hash 部分中，网址看起来是这样的 <code>http://example.com/#/your/page</code> 。
hash 值不会发送到服务器中，也就意味着不需要特殊的服务器配置。</li>
</ul>

<p>
使用 Router 要确保顶层的 <code>&lt;App /&gt;</code> 放在 Router 之中，如下：
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5317ac;">import</span> React from <span style="color: #2544bb;">"react"</span>;
<span style="color: #5317ac;">import</span> ReactDOM from <span style="color: #2544bb;">"react-dom"</span>;
<span style="color: #5317ac;">import</span> <span style="color: #000000;">{</span> BrowserRouter <span style="color: #000000;">}</span> from <span style="color: #2544bb;">"react-router-dom"</span>;

<span style="color: #5317ac;">function</span> <span style="color: #721045;">App</span><span style="color: #000000;">()</span> <span style="color: #000000;">{</span>
  <span style="color: #5317ac;">return</span> <span style="color: #a8007f;">&lt;</span><span style="color: #721045;">h1</span><span style="color: #a8007f;">&gt;</span><span style="color: #000000; background-color: #ffffff;">Hello React Router</span><span style="color: #a8007f;">&lt;</span>/<span style="color: #721045;">h1</span><span style="color: #a8007f;">&gt;</span>;
<span style="color: #000000;">}</span>

ReactDOM.render<span style="color: #000000;">(</span>
  <span style="color: #a8007f;">&lt;</span><span style="color: #721045;">BrowserRouter</span><span style="color: #a8007f;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">    </span><span style="color: #a8007f;">&lt;</span><span style="color: #721045;">App</span> /<span style="color: #a8007f;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">  </span><span style="color: #a8007f;">&lt;</span>/<span style="color: #721045;">BrowserRouter</span><span style="color: #a8007f;">&gt;</span>,
  document.getElementById<span style="color: #a8007f;">(</span><span style="color: #2544bb;">"root"</span><span style="color: #a8007f;">)</span>
<span style="color: #000000;">)</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb73c5e7" class="outline-4">
<h4 id="orgb73c5e7"><span class="section-number-4">1.1.2.</span> 路由匹配</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
有两个路由匹配组件： <code>Switch</code> 和 <code>Route</code> 。当 <code>&lt;Switch&gt;</code> 渲染的时候，它会搜索它的 <span class="underline">子</span> <code>&lt;Route&gt;</code> 元素，找到与当前 URL 匹配的元素。
匹配到之后就会忽略其他的路由。也就意味着特殊的路径要放在不特殊路径的 <b>前面</b> 。
</p>

<p>
如果找不到匹配项， <code>&lt;Switch&gt;</code> 会什么都不渲染（null）。
</p>

<p>
值得注意的是， <code>&lt;Route path&gt;</code> 只会匹配 URL 的 <b>开头</b> ，不是全部。所以 <code>&lt;Route path="/"&gt;</code> 总是会匹配所有的 URL。
因为这个原因，我们通常把它放在 <code>&lt;Switch&gt;</code> 的最后。另外一个解决办法是使用 <code>exact</code> 参数，全部匹配路径，比如： <code>&lt;Route exact path="/"&gt;</code> 。
</p>
</div>
</div>

<div id="outline-container-org336989e" class="outline-4">
<h4 id="org336989e"><span class="section-number-4">1.1.3.</span> 路由变更（Nav）</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
React Router 提供了 <code>&lt;Link&gt;</code> 组件来创建链接。当使用 <code>&lt;Link&gt;</code> 的时候，会渲染成 anchor（ <code>&lt;a&gt;</code> ）。
</p>

<p>
<code>&lt;NavLink&gt;</code> 是 <code>&lt;Link&gt;</code> 的一种特殊类型，当其 prop 与当前位置匹配时，可以将其自身设置为「活动」。比如：
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #721045;">NavLink</span> <span style="color: #00538b;">to</span>=<span style="color: #2544bb;">"/react"</span> <span style="color: #00538b;">activeClassName</span>=<span style="color: #2544bb;">"hurray"</span>&gt;
  React
&lt;/<span style="color: #721045;">NavLink</span>&gt;
</pre>
</div>

<p>
可以用于对当前选中的页面做一些特殊的样式设置之类的。
</p>

<p>
如果想要强制导航，你可以使用 <code>&lt;Redirect&gt;</code> 。当渲染的时候，它会使用 prop 进行导航。
</p>
</div>
</div>
</div>

<div id="outline-container-orga177d55" class="outline-3">
<h3 id="orga177d55"><span class="section-number-3">1.2.</span> <span class="todo TODO">TODO</span> 服务端渲染（Server Rendering）</h3>
</div>
<div id="outline-container-org44bd374" class="outline-3">
<h3 id="org44bd374"><span class="section-number-3">1.3.</span> 代码拆分（Code Splitting）</h3>
<div class="outline-text-3" id="text-1-3">
<p>
代码拆分可以理解成代码按需加载。为了实现这个目标，需要使用 webpack， <code>@babel/plugin-syntax-dynamic-import</code> 和 loadable-components。
</p>

<p>
webpack 默认支持动态导入；但是，你如果使用了 Babel（比如：把 JSX 编译成 JavaScript），那么你就需要使用 @babel/plugin-syntax-dynamic-import 插件。
这只是一个语法插件，意味着 Babel 不会做任何额外的转换。该插件仅允许 Babel 解析动态导入，因此 webpack 可以将 bundle 他们作为代码拆分。你的 <code>.babelrc</code> 可能长这样：
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #000000;">{</span>
  <span style="color: #2544bb;">"presets"</span>: <span style="color: #a8007f;">[</span><span style="color: #2544bb;">"@babel/preset-react"</span><span style="color: #a8007f;">]</span>,
  <span style="color: #2544bb;">"plugins"</span>: <span style="color: #a8007f;">[</span><span style="color: #2544bb;">"@babel/plugin-syntax-dynamic-import"</span><span style="color: #a8007f;">]</span>
<span style="color: #000000;">}</span>
</pre>
</div>

<p>
loadable-components 是一个库加载组件用来动态导入。它自动处理各种边缘情况，使代码拆分变的很简单。下面是使用范例：
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5317ac;">import</span> loadable from <span style="color: #2544bb;">"@loadable/component"</span>;
<span style="color: #5317ac;">import</span> Loading from <span style="color: #2544bb;">"./Loading.js"</span>;

<span style="color: #5317ac;">const</span> <span style="color: #00538b;">LoadableComponent</span> = loadable<span style="color: #000000;">(</span><span style="color: #a8007f;">()</span> =&gt; <span style="color: #5317ac;">import</span><span style="color: #a8007f;">(</span><span style="color: #2544bb;">"./Dashboard.js"</span><span style="color: #a8007f;">)</span>, <span style="color: #a8007f;">{</span>
  fallback: &lt;Loading /&gt;
<span style="color: #a8007f;">}</span><span style="color: #000000;">)</span>;

<span style="color: #5317ac;">export</span> <span style="color: #5317ac;">default</span> <span style="color: #5317ac;">class</span> LoadableDashboard <span style="color: #5317ac;">extends</span> React.Component <span style="color: #000000;">{</span>
  render<span style="color: #a8007f;">()</span> <span style="color: #a8007f;">{</span>
    <span style="color: #5317ac;">return</span> &lt;LoadableComponent /&gt;;
  <span style="color: #a8007f;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div>

<p>
当程序运行时，动态加载，fallback 是加载期间展示的组件。
</p>
</div>
</div>

<div id="outline-container-org7949e56" class="outline-3">
<h3 id="org7949e56"><span class="section-number-3">1.4.</span> 滚动恢复</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org30143cc" class="outline-4">
<h4 id="org30143cc"><span class="section-number-4">1.4.1.</span> 滚动到顶部</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
当有一个长页面时，经常有滚动到顶部的需求。使用 <code>&lt;ScrollToTop&gt;</code> 可以轻松解决这个问题，该组件将在每次导航时向上滚动窗口。
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5317ac;">import</span> <span style="color: #000000;">{</span> useEffect <span style="color: #000000;">}</span> from <span style="color: #2544bb;">"react"</span>;
<span style="color: #5317ac;">import</span> <span style="color: #000000;">{</span> useLocation <span style="color: #000000;">}</span> from <span style="color: #2544bb;">"react-router-dom"</span>;

<span style="color: #5317ac;">export</span> <span style="color: #5317ac;">default</span> <span style="color: #5317ac;">function</span> ScrollToTop<span style="color: #000000;">()</span> <span style="color: #000000;">{</span>
  <span style="color: #5317ac;">const</span> <span style="color: #a8007f;">{</span> pathname <span style="color: #a8007f;">}</span> = useLocation<span style="color: #a8007f;">()</span>;

  useEffect<span style="color: #a8007f;">(</span><span style="color: #005f88;">()</span> =&gt; <span style="color: #005f88;">{</span>
    window.scrollTo<span style="color: #904200;">(</span>0, 0<span style="color: #904200;">)</span>;
  <span style="color: #005f88;">}</span>, <span style="color: #005f88;">[</span>pathname<span style="color: #005f88;">]</span><span style="color: #a8007f;">)</span>;

  <span style="color: #5317ac;">return</span> <span style="color: #0000c0;">null</span>;
<span style="color: #000000;">}</span>
</pre>
</div>

<p>
如果你用的是 React 16.8 之前的版本，你可以用 <code>React.Component</code> 来做相同的事情：
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5317ac;">import</span> React from <span style="color: #2544bb;">"react"</span>;
<span style="color: #5317ac;">import</span> <span style="color: #000000;">{</span> withRouter <span style="color: #000000;">}</span> from <span style="color: #2544bb;">"react-router-dom"</span>;

<span style="color: #5317ac;">class</span> ScrollToTop <span style="color: #5317ac;">extends</span> React.Component <span style="color: #000000;">{</span>
  componentDidUpdate<span style="color: #a8007f;">(</span>prevProps<span style="color: #a8007f;">)</span> <span style="color: #a8007f;">{</span>
    <span style="color: #5317ac;">if</span> <span style="color: #005f88;">(</span>
      <span style="color: #0000c0;">this</span>.props.location.pathname !== prevProps.location.pathname
    <span style="color: #005f88;">)</span> <span style="color: #005f88;">{</span>
      window.scrollTo<span style="color: #904200;">(</span>0, 0<span style="color: #904200;">)</span>;
    <span style="color: #005f88;">}</span>
  <span style="color: #a8007f;">}</span>

  render<span style="color: #a8007f;">()</span> <span style="color: #a8007f;">{</span>
    <span style="color: #5317ac;">return</span> <span style="color: #0000c0;">null</span>;
  <span style="color: #a8007f;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #5317ac;">export</span> <span style="color: #5317ac;">default</span> withRouter<span style="color: #000000;">(</span>ScrollToTop<span style="color: #000000;">)</span>;
</pre>
</div>

<p>
然后把他们放在应用的顶部，路由器的下方：
</p>

<pre class="example">
function App() {
  return (
    &lt;Router&gt;
      &lt;ScrollToTop /&gt;
      &lt;App /&gt;
    &lt;/Router&gt;
  );
}
</pre>

<p>
如果你将标签页连接到路由器，那么当切换标签页时，你不希望滚动到顶部。而是滚动到特定位置。
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5317ac;">import</span> <span style="color: #000000;">{</span> useEffect <span style="color: #000000;">}</span> from <span style="color: #2544bb;">"react"</span>;

<span style="color: #5317ac;">function</span> <span style="color: #721045;">ScrollToTopOnMount</span><span style="color: #000000;">()</span> <span style="color: #000000;">{</span>
  useEffect<span style="color: #a8007f;">(</span><span style="color: #005f88;">()</span> =&gt; <span style="color: #005f88;">{</span>
    window.scrollTo<span style="color: #904200;">(</span>0, 0<span style="color: #904200;">)</span>;
  <span style="color: #005f88;">}</span>, <span style="color: #005f88;">[]</span><span style="color: #a8007f;">)</span>;

  <span style="color: #5317ac;">return</span> <span style="color: #0000c0;">null</span>;
<span style="color: #000000;">}</span>

<span style="color: #505050;">// </span><span style="color: #505050;">Render this somewhere using:</span>
<span style="color: #505050;">// </span><span style="color: #505050;">&lt;Route path="..." children={&lt;LongContent /&gt;} /&gt;</span>
<span style="color: #5317ac;">function</span> <span style="color: #721045;">LongContent</span><span style="color: #000000;">()</span> <span style="color: #000000;">{</span>
  <span style="color: #5317ac;">return</span> <span style="color: #a8007f;">(</span>
    &lt;div&gt;
      &lt;ScrollToTopOnMount /&gt;

      &lt;h1&gt;Here is my <span style="color: #005a5f;">long</span> <span style="color: #00538b;">content</span> page&lt;/h1&gt;
      &lt;p&gt;...&lt;/p&gt;
    &lt;/div&gt;
  <span style="color: #a8007f;">)</span>;
<span style="color: #000000;">}</span>
</pre>
</div>

<p>
同样，如果使用 React 16.8 以前的版本，可以这么做：
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5317ac;">import</span> React from <span style="color: #2544bb;">"react"</span>;

<span style="color: #5317ac;">class</span> ScrollToTopOnMount <span style="color: #5317ac;">extends</span> React.Component <span style="color: #000000;">{</span>
  componentDidMount<span style="color: #a8007f;">()</span> <span style="color: #a8007f;">{</span>
    window.scrollTo<span style="color: #005f88;">(</span>0, 0<span style="color: #005f88;">)</span>;
  <span style="color: #a8007f;">}</span>

  render<span style="color: #a8007f;">()</span> <span style="color: #a8007f;">{</span>
    <span style="color: #5317ac;">return</span> <span style="color: #0000c0;">null</span>;
  <span style="color: #a8007f;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #505050;">// </span><span style="color: #505050;">Render this somewhere using:</span>
<span style="color: #505050;">// </span><span style="color: #505050;">&lt;Route path="..." children={&lt;LongContent /&gt;} /&gt;</span>
<span style="color: #5317ac;">class</span> LongContent <span style="color: #5317ac;">extends</span> React.Component <span style="color: #000000;">{</span>
  render<span style="color: #a8007f;">()</span> <span style="color: #a8007f;">{</span>
    <span style="color: #5317ac;">return</span> <span style="color: #005f88;">(</span>
      <span style="color: #904200;">&lt;</span><span style="color: #721045;">div</span><span style="color: #904200;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">        </span><span style="color: #904200;">&lt;</span><span style="color: #721045;">ScrollToTopOnMount</span> /<span style="color: #904200;">&gt;</span>

<span style="color: #000000; background-color: #ffffff;">        </span><span style="color: #904200;">&lt;</span><span style="color: #721045;">h1</span><span style="color: #904200;">&gt;</span><span style="color: #000000; background-color: #ffffff;">Here is my long content page</span><span style="color: #904200;">&lt;</span>/<span style="color: #721045;">h1</span><span style="color: #904200;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">        </span><span style="color: #904200;">&lt;</span><span style="color: #721045;">p</span><span style="color: #904200;">&gt;</span><span style="color: #000000; background-color: #ffffff;">...</span><span style="color: #904200;">&lt;</span>/<span style="color: #721045;">p</span><span style="color: #904200;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">      </span><span style="color: #904200;">&lt;</span>/<span style="color: #721045;">div</span><span style="color: #904200;">&gt;</span>
    <span style="color: #005f88;">)</span>;
  <span style="color: #a8007f;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org2cfbbb8" class="outline-4">
<h4 id="org2cfbbb8"><span class="section-number-4">1.4.2.</span> 通用的解决方案</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
对于通用的解决办法（浏览器已经开始原生实现），我们讨论两件事情：
</p>

<ol class="org-ol">
<li>向上滚动导航，这样就不会开始一个新的底部屏幕</li>
<li>恢复滚动位置，点击「后退」和「前进」溢出元素（但不是点击链接）</li>
</ol>

<p>
在这个点上，我们希望要有一个通用的 API，答题思路是这样的：
</p>

<div class="org-src-container">
<pre class="src src-javascript">&lt;Router&gt;
  &lt;ScrollRestoration&gt;
    &lt;div&gt;
      &lt;h1&gt;App&lt;/h1&gt;

      &lt;RestoredScroll id=<span style="color: #2544bb;">"bunny"</span>&gt;
        &lt;div style=<span style="color: #000000;">{</span><span style="color: #a8007f;">{</span> height: <span style="color: #2544bb;">"200px"</span>, overflow: <span style="color: #2544bb;">"auto"</span> <span style="color: #a8007f;">}</span><span style="color: #000000;">}</span>&gt;
          I will overflow
        &lt;/div&gt;
      &lt;/RestoredScroll&gt;
    &lt;/div&gt;
  &lt;/ScrollRestoration&gt;
&lt;/Router&gt;
</pre>
</div>

<p>
首先， <code>ScrollRestoration</code> 会向上滚动导航；其次，它会用 <code>location.key</code> 保存窗口滚动位置，并且 <code>ScrollRestoration</code> 的位置放在 <code>sessionStorage</code> 。
然后，当 <code>ScrollRestoration</code> 或者 <code>RestoredScroll</code> 组件挂载时，他们可以从 <code>sessionStorage</code> 中查找他们的位置。
</p>

<p>
<i>说了半天，原来都是设想，不看了..</i>
</p>
</div>
</div>
</div>

<div id="outline-container-org21e7f86" class="outline-3">
<h3 id="org21e7f86"><span class="section-number-3">1.5.</span> 原理</h3>
<div class="outline-text-3" id="text-1-5">
<p>
这份指南的目的是说明使用 React Router 时要具有的思维模型。我们称作「动态路由」，与你熟悉的「静态路由」完全不同 。
</p>
</div>

<div id="outline-container-org4b5758f" class="outline-4">
<h4 id="org4b5758f"><span class="section-number-4">1.5.1.</span> 静态路由</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
如果你用过 Rails，Express，Angular 等。那你就已经用过静态路由了。在这些框架中，所有的路由部分都要放在应用初始化任何渲染的前面。
React Router pre-v4 也是静态的（大部分）。让我们看一下在 Express 中是如何动态配置路由的：
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #505050;">// </span><span style="color: #505050;">Express Style routing:</span>
app.get<span style="color: #000000;">(</span><span style="color: #2544bb;">"/"</span>, handleIndex<span style="color: #000000;">)</span>;
app.get<span style="color: #000000;">(</span><span style="color: #2544bb;">"/invoices"</span>, handleInvoices<span style="color: #000000;">)</span>;
app.get<span style="color: #000000;">(</span><span style="color: #2544bb;">"/invoices/:id"</span>, handleInvoice<span style="color: #000000;">)</span>;
app.get<span style="color: #000000;">(</span><span style="color: #2544bb;">"/invoices/:id/edit"</span>, handleInvoiceEdit<span style="color: #000000;">)</span>;

app.listen<span style="color: #000000;">()</span>;
</pre>
</div>

<p>
注意，是在程序监听之前是如何生命路由的。客户端一侧的路由也是类似的。在 Angular 中，你也要提前声明好路由，
然后在顶部导入他们（ <code>AppModule</code> 渲染之前）：
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #505050;">// </span><span style="color: #505050;">Angular Style routing:</span>
<span style="color: #5317ac;">const</span> <span style="color: #00538b;">appRoutes</span>: Routes = <span style="color: #000000;">[</span>
  <span style="color: #a8007f;">{</span>
    path: <span style="color: #2544bb;">"crisis-center"</span>,
    component: CrisisListComponent
  <span style="color: #a8007f;">}</span>,
  <span style="color: #a8007f;">{</span>
    path: <span style="color: #2544bb;">"hero/:id"</span>,
    component: HeroDetailComponent
  <span style="color: #a8007f;">}</span>,
  <span style="color: #a8007f;">{</span>
    path: <span style="color: #2544bb;">"heroes"</span>,
    component: HeroListComponent,
    data: <span style="color: #005f88;">{</span> title: <span style="color: #2544bb;">"Heroes List"</span> <span style="color: #005f88;">}</span>
  <span style="color: #a8007f;">}</span>,
  <span style="color: #a8007f;">{</span>
    path: <span style="color: #2544bb;">""</span>,
    redirectTo: <span style="color: #2544bb;">"/heroes"</span>,
    pathMatch: <span style="color: #2544bb;">"full"</span>
  <span style="color: #a8007f;">}</span>,
  <span style="color: #a8007f;">{</span>
    path: <span style="color: #2544bb;">"**"</span>,
    component: PageNotFoundComponent
  <span style="color: #a8007f;">}</span>
<span style="color: #000000;">]</span>;

@NgModule<span style="color: #000000;">(</span><span style="color: #a8007f;">{</span>
  imports: <span style="color: #005f88;">[</span>RouterModule.forRoot<span style="color: #904200;">(</span>appRoutes<span style="color: #904200;">)</span><span style="color: #005f88;">]</span>
<span style="color: #a8007f;">}</span><span style="color: #000000;">)</span>
<span style="color: #5317ac;">export</span> <span style="color: #5317ac;">class</span> AppModule <span style="color: #000000;">{}</span>
</pre>
</div>

<p>
Ember 使用了比较常规的 <code>routes.js</code> 文件，但也是在你的程序渲染之前做的：
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #505050;">// </span><span style="color: #505050;">Ember Style Router:</span>
Router.map<span style="color: #000000;">(</span><span style="color: #5317ac;">function</span><span style="color: #a8007f;">()</span> <span style="color: #a8007f;">{</span>
  <span style="color: #0000c0;">this</span>.route<span style="color: #005f88;">(</span><span style="color: #2544bb;">"about"</span><span style="color: #005f88;">)</span>;
  <span style="color: #0000c0;">this</span>.route<span style="color: #005f88;">(</span><span style="color: #2544bb;">"contact"</span><span style="color: #005f88;">)</span>;
  <span style="color: #0000c0;">this</span>.route<span style="color: #005f88;">(</span><span style="color: #2544bb;">"rentals"</span>, <span style="color: #5317ac;">function</span><span style="color: #904200;">()</span> <span style="color: #904200;">{</span>
    <span style="color: #0000c0;">this</span>.route<span style="color: #7f10d0;">(</span><span style="color: #2544bb;">"show"</span>, <span style="color: #006800;">{</span> path: <span style="color: #2544bb;">"/:rental_id"</span> <span style="color: #006800;">}</span><span style="color: #7f10d0;">)</span>;
  <span style="color: #904200;">}</span><span style="color: #005f88;">)</span>;
<span style="color: #a8007f;">}</span><span style="color: #000000;">)</span>;

<span style="color: #5317ac;">export</span> <span style="color: #5317ac;">default</span> Router;
</pre>
</div>

<p>
尽管 API 不同，但他们都是「静态路由」模型，React Router 也一直跟进到 V4。
</p>

<p>
为了用好 React Router，你需要忘了这些。
</p>
</div>
</div>

<div id="outline-container-org63b897e" class="outline-4">
<h4 id="org63b897e"><span class="section-number-4">1.5.2.</span> 动态路由</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
所谓动态路由指的是在应用渲染的时候进行的路由，不是程序之外的配置或者约定。也就是说所有的路由都是 React Router 中的组件。
下面是 API 审查，帮助你了解其工作原理：
</p>

<p>
首先，在需要渲染应用的顶部添加 Router 组件：
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #505050;">// </span><span style="color: #505050;">react-native</span>
<span style="color: #5317ac;">import</span> <span style="color: #000000;">{</span> NativeRouter <span style="color: #000000;">}</span> from <span style="color: #2544bb;">"react-router-native"</span>;

<span style="color: #505050;">// </span><span style="color: #505050;">react-dom (what we'll use here)</span>
<span style="color: #5317ac;">import</span> <span style="color: #000000;">{</span> BrowserRouter <span style="color: #000000;">}</span> from <span style="color: #2544bb;">"react-router-dom"</span>;

ReactDOM.render<span style="color: #000000;">(</span>
  &lt;BrowserRouter&gt;
    &lt;App /&gt;
  &lt;/BrowserRouter&gt;,
  el
<span style="color: #000000;">)</span>;
</pre>
</div>

<p>
然后，使用链接组件链接到新的位置：
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5317ac;">const</span> <span style="color: #00538b;">App</span> = <span style="color: #000000;">()</span> =&gt; <span style="color: #000000;">(</span>
  &lt;div&gt;
    &lt;nav&gt;
      &lt;Link to=<span style="color: #2544bb;">"/dashboard"</span>&gt;Dashboard&lt;/Link&gt;
    &lt;/nav&gt;
  &lt;/div&gt;
<span style="color: #000000;">)</span>;
</pre>
</div>

<p>
最后，使用 Route 把路径路由到 UI 组件上。
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5317ac;">const</span> <span style="color: #00538b;">App</span> = <span style="color: #000000;">()</span> =&gt; <span style="color: #000000;">(</span>
  &lt;div&gt;
    &lt;nav&gt;
      &lt;Link to=<span style="color: #2544bb;">"/dashboard"</span>&gt;Dashboard&lt;/Link&gt;
    &lt;/nav&gt;
    &lt;div&gt;
      &lt;Route path=<span style="color: #2544bb;">"/dashboard"</span> component=<span style="color: #a8007f;">{</span>Dashboard<span style="color: #a8007f;">}</span> /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
<span style="color: #000000;">)</span>;
</pre>
</div>

<p>
Route 会渲染成 <code>&lt;Dashboard {...props}/&gt;</code>, <code>props</code> 是路由器相关的信息，比如 <code>{ match, location, history }</code> ，如果用户不是 <code>/dashboard</code> 路径
会渲染成 <code>null</code> 。这基本上就是路由的全部了。
</p>
</div>
</div>

<div id="outline-container-org1fa49bd" class="outline-4">
<h4 id="org1fa49bd"><span class="section-number-4">1.5.3.</span> 嵌套路由</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
许多路由器都有嵌套路由的概念，如果你用了 V4 的 React Router，那么你就知道它也是这样的。只要嵌套 <code>div</code> 就可以了：
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5317ac;">const</span> <span style="color: #00538b;">App</span> = <span style="color: #000000;">()</span> =&gt; <span style="color: #000000;">(</span>
  &lt;BrowserRouter&gt;
    <span style="color: #a8007f;">{</span><span style="color: #505050;">/* </span><span style="color: #505050;">here's a div</span><span style="color: #505050;"> */</span><span style="color: #a8007f;">}</span>
    &lt;div&gt;
      <span style="color: #a8007f;">{</span><span style="color: #505050;">/* </span><span style="color: #505050;">here's a Route</span><span style="color: #505050;"> */</span><span style="color: #a8007f;">}</span>
      &lt;Route path=<span style="color: #2544bb;">"/tacos"</span> component=<span style="color: #a8007f;">{</span>Tacos<span style="color: #a8007f;">}</span> /&gt;
    &lt;/div&gt;
  &lt;/BrowserRouter&gt;
<span style="color: #000000;">)</span>;

<span style="color: #505050;">// </span><span style="color: #505050;">when the url matches `/tacos` this component renders</span>
<span style="color: #5317ac;">const</span> <span style="color: #00538b;">Tacos</span> = <span style="color: #000000;">(</span><span style="color: #a8007f;">{</span> match <span style="color: #a8007f;">}</span><span style="color: #000000;">)</span> =&gt; <span style="color: #000000;">(</span>
  <span style="color: #505050;">// </span><span style="color: #505050;">here's a nested div</span>
  &lt;div&gt;
    <span style="color: #a8007f;">{</span><span style="color: #505050;">/* </span><span style="color: #505050;">here's a nested Route,</span>
<span style="color: #505050;">        match.url helps us make a relative path</span><span style="color: #505050;"> */</span><span style="color: #a8007f;">}</span>
    &lt;Route path=<span style="color: #a8007f;">{</span>match.url + <span style="color: #2544bb;">"/carnitas"</span><span style="color: #a8007f;">}</span> component=<span style="color: #a8007f;">{</span>Carnitas<span style="color: #a8007f;">}</span> /&gt;
  &lt;/div&gt;
<span style="color: #000000;">)</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgda5c459" class="outline-4">
<h4 id="orgda5c459"><span class="section-number-4">1.5.4.</span> 响应式路由</h4>
</div>
</div>
</div>
<div id="outline-container-orgd86f912" class="outline-2">
<h2 id="orgd86f912"><span class="section-number-2">2.</span> API</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org1a113d4" class="outline-3">
<h3 id="org1a113d4"><span class="section-number-3">2.1.</span> Hooks</h3>
<div class="outline-text-3" id="text-2-1">
<p>
React 16.8 版本之后，React Router 利用 hook 机制添加了几种常用的 hooks：
</p>

<ul class="org-ul">
<li><a href="https://reacttraining.com/react-router/web/api/Hooks/usehistory">useHistory</a>，得到一个 history 实例</li>
<li><a href="https://reacttraining.com/react-router/web/api/Hooks/uselocation">useLocation</a>，得到一个 location 对象</li>
<li><a href="https://reacttraining.com/react-router/web/api/Hooks/useparams">useParams</a>，返回 URL 参数中变量的键值对</li>
<li><a href="https://reacttraining.com/react-router/web/api/Hooks/useroutematch">useRouteMatch</a>，以 <code>&lt;Route&gt;</code> 相同的方式 match 当前 URL</li>
</ul>
</div>
</div>

<div id="outline-container-orgd27420c" class="outline-3">
<h3 id="orgd27420c"><span class="section-number-3">2.2.</span> <code>&lt;BrowserRouter&gt;</code></h3>
<div class="outline-text-3" id="text-2-2">
<p>
<code>&lt;Router&gt;</code> 使用 HTML5 history API 保证 UI 界面与 URL 同步。
</p>

<div class="org-src-container">
<pre class="src src-javascript">&lt;BrowserRouter
  basename=<span style="color: #000000;">{</span>optionalString<span style="color: #000000;">}</span>
  forceRefresh=<span style="color: #000000;">{</span>optionalBool<span style="color: #000000;">}</span>
  getUserConfirmation=<span style="color: #000000;">{</span>optionalFunc<span style="color: #000000;">}</span>
  keyLength=<span style="color: #000000;">{</span>optionalNumber<span style="color: #000000;">}</span>
&gt;
  &lt;App /&gt;
&lt;/BrowserRouter&gt;
</pre>
</div>

<ul class="org-ul">
<li><code>basename: string</code> 所有路径的基准路径</li>
<li><code>getUserConfirmation: func</code></li>
<li><code>forceRefresh: bool</code> true 时，新页面导航会强制刷新页面</li>
<li><code>keyLength: number</code> location.key 的长度，默认是 6</li>
<li><code>children: node</code> 要渲染的子元素</li>
</ul>
</div>
</div>

<div id="outline-container-org33c9375" class="outline-3">
<h3 id="org33c9375"><span class="section-number-3">2.3.</span> <code>&lt;HashRouter&gt;</code></h3>
<div class="outline-text-3" id="text-2-3">
<p>
<code>&lt;Router&gt;</code> 使用 URL 中的 hash 部分（比如 <code>window.location.hash</code> ）来保证你的 UI 与 URL 同步。
</p>

<p>
<b>注意：</b> hash history 不支持 <code>location.key</code> 或者 <code>location.state</code> 。建议服务器配置和 <code>&lt;BrowserHistory&gt;</code> 一起用。
</p>

<div class="org-src-container">
<pre class="src src-javascript">&lt;HashRouter
  basename=<span style="color: #000000;">{</span>optionalString<span style="color: #000000;">}</span>
  getUserConfirmation=<span style="color: #000000;">{</span>optionalFunc<span style="color: #000000;">}</span>
  hashType=<span style="color: #000000;">{</span>optionalString<span style="color: #000000;">}</span>
&gt;
  &lt;App /&gt;
&lt;/HashRouter&gt;
</pre>
</div>

<ul class="org-ul">
<li><code>basename: string</code></li>
<li><code>getUserConfirmation: func</code></li>
<li><code>hashType: string</code> <code>window.location.hash</code> 的编码类型，可选的值：
<ul class="org-ul">
<li>slash，类似 <code>#/</code> ， <code>#/sunshine/lollipops</code> 。 默认选项。</li>
<li>noslash，类似 <code>#</code> ， <code>#sunshine/lollipops</code></li>
<li>hashbang，类似 <code>#!/</code> ， <code>#!/sunshine/lollipops</code></li>
</ul></li>
<li><code>children: node</code></li>
</ul>
</div>
</div>
<div id="outline-container-org9742f83" class="outline-3">
<h3 id="org9742f83"><span class="section-number-3">2.4.</span> <code>&lt;Link&gt;</code></h3>
<div class="outline-text-3" id="text-2-4">
<p>
应用内部的导航（可路由的 URL）。
</p>

<div class="org-src-container">
<pre class="src src-javascript">&lt;Link to=<span style="color: #2544bb;">"/about"</span>&gt;About&lt;/Link&gt;
</pre>
</div>

<ul class="org-ul">
<li><code>to</code> 导航目标，支持几种类型
<ul class="org-ul">
<li><p>
<code>string</code> 字符串将 location.pathname, search, hash 属性拼接起来
</p>
<div class="org-src-container">
<pre class="src src-javascript">&lt;Link to=<span style="color: #2544bb;">"/courses?sort=name"</span> /&gt;
</pre>
</div></li>
<li><code>object</code> 包含一下任何属性的对象
<ul class="org-ul">
<li><code>pathname</code></li>
<li><code>search</code></li>
<li><code>hash</code></li>
<li><p>
<code>state</code>
</p>
<div class="org-src-container">
<pre class="src src-javascript">&lt;Link
  to=<span style="color: #000000;">{</span><span style="color: #a8007f;">{</span>
  pathname: <span style="color: #2544bb;">"/courses"</span>,
  search: <span style="color: #2544bb;">"?sort=name"</span>,
  hash: <span style="color: #2544bb;">"#the-hash"</span>,
  state: <span style="color: #005f88;">{</span> fromDashboard: <span style="color: #0000c0;">true</span> <span style="color: #005f88;">}</span>
  <span style="color: #a8007f;">}</span><span style="color: #000000;">}</span>
<span style="color: #2544bb;">/&gt;</span>
</pre>
</div></li>
</ul></li>
<li><p>
<code>function</code> 当前位置作为参数传给函数，返回字符串形式的或者对象形式的位置
</p>
<div class="org-src-container">
<pre class="src src-javascript">&lt;Link to=<span style="color: #000000;">{</span>location =&gt; <span style="color: #a8007f;">(</span><span style="color: #005f88;">{</span> ...location, pathname: <span style="color: #2544bb;">"/courses"</span> <span style="color: #005f88;">}</span><span style="color: #a8007f;">)</span><span style="color: #000000;">}</span> /&gt;
&lt;Link to=<span style="color: #000000;">{</span>location =&gt; <span style="color: #a8007f;">(</span><span style="color: #005f88;">{</span> ...location, pathname: <span style="color: #2544bb;">"/courses"</span> <span style="color: #005f88;">}</span><span style="color: #a8007f;">)</span><span style="color: #000000;">}</span> /&gt;
</pre>
</div></li>
</ul></li>
<li><code>replace: bool</code> true 会替换当前 history 堆栈中的链接，而不是重新添加一个</li>
<li>其它，你也可以传递想要给 <code>&lt;a&gt;</code> 的项目，比如 title，id，className 等等。</li>
</ul>
</div>
</div>

<div id="outline-container-orgacdfed4" class="outline-3">
<h3 id="orgacdfed4"><span class="section-number-3">2.5.</span> <code>&lt;NavLink&gt;</code></h3>
<div class="outline-text-3" id="text-2-5">
<p>
<code>&lt;Link&gt;</code> 的特殊版本，如果匹配当前的 URL 时，自动添加风格属性。
</p>

<div class="org-src-container">
<pre class="src src-javascript">&lt;NavLink to=<span style="color: #2544bb;">"/about"</span>&gt;About&lt;/NavLink&gt;
</pre>
</div>

<ul class="org-ul">
<li><p>
<code>activeClassName: string</code> 激活状态下给定元素的 <code>class</code> ，默认是 <code>active</code> ，或者 <code>className</code> 属性联合起来
</p>
<div class="org-src-container">
<pre class="src src-javascript">&lt;NavLink to=<span style="color: #2544bb;">"/faq"</span> activeClassName=<span style="color: #2544bb;">"selected"</span>&gt;
  FAQs
&lt;/NavLink&gt;
</pre>
</div></li>
<li><p>
<code>activeStyle: object</code> 激活状态下的元素样式，这是一个对象
</p>
<div class="org-src-container">
<pre class="src src-javascript">&lt;NavLink
  to=<span style="color: #2544bb;">"/faq"</span>
  activeStyle=<span style="color: #000000;">{</span><span style="color: #a8007f;">{</span>
    fontWeight: <span style="color: #2544bb;">"bold"</span>,
    color: <span style="color: #2544bb;">"red"</span>
  <span style="color: #a8007f;">}</span><span style="color: #000000;">}</span>
&gt;
  FAQs
&lt;/NavLink&gt;
</pre>
</div></li>
<li><code>exact: bool</code> true 时，路径完全匹配 style 才生效</li>
<li><p>
<code>strict: bool</code> true 时，匹配是否考虑路径名上的斜杠，更多可查看 <code>&lt;Route strict&gt;</code> 文档
</p>
<div class="org-src-container">
<pre class="src src-javascript">&lt;NavLink strict to=<span style="color: #2544bb;">"/events/"</span>&gt;
  Events
&lt;/NavLink&gt;
</pre>
</div></li>
<li><code>isActive: func</code> 如果你不想使用默认的判断逻辑的话，可以用该函数自定义，参数是 <code>(match, location)</code></li>
<li><code>location: object</code> 一般是浏览器 URL，在自定义 <code>isActive</code> 的时候，会传入</li>
</ul>
</div>
</div>
<div id="outline-container-org3a8bcec" class="outline-3">
<h3 id="org3a8bcec"><span class="section-number-3">2.6.</span> <code>&lt;MemoryRouter&gt;</code></h3>
<div class="outline-text-3" id="text-2-6">
<p>
将 URL 记录保留在内存中（不在地址栏读取或者写入），在测试和非浏览器环境中（React Native）很有用。
</p>
</div>
</div>

<div id="outline-container-org657f18f" class="outline-3">
<h3 id="org657f18f"><span class="section-number-3">2.7.</span> <code>&lt;Redirect&gt;</code></h3>
<div class="outline-text-3" id="text-2-7">
<p>
重定向到另外一个位置，新的位置将覆盖历史记录堆栈中的当前位置，类似服务端的 redirects （HTTP 3xx） 干的事情。
</p>

<ul class="org-ul">
<li><code>to: string</code> 字符串表达的位置</li>
<li><p>
<code>to: object</code> 对象表达的位置，路径格式必须要被 <a href="https://github.com/pillarjs/path-to-regexp/tree/v1.7.0">path-to-regexp@^1.7.0</a> 理解
</p>
<div class="org-src-container">
<pre class="src src-javascript">&lt;Redirect
  to=<span style="color: #000000;">{</span><span style="color: #a8007f;">{</span>
    pathname: <span style="color: #2544bb;">"/login"</span>,
    search: <span style="color: #2544bb;">"?utm=your+face"</span>,
    state: <span style="color: #005f88;">{</span> referrer: currentLocation <span style="color: #005f88;">}</span>
  <span style="color: #a8007f;">}</span><span style="color: #000000;">}</span>
<span style="color: #2544bb;">/&gt;</span>
</pre>
</div>
<p>
<code>state</code> 对象可以被重定向的对象直接使用，比如 <code>this.props.location.state.referrer</code> 。
</p></li>
<li><code>push: bool</code> 如果是 true 的话，重定向将在 history 中新增一条记录，而不是替换当前记录</li>
<li><p>
<code>from: string</code> 重定向的来源 URL，参数会被传递到 <code>to</code> 中：
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #505050;">// </span><span style="color: #505050;">Redirect with matched parameters</span>
&lt;Switch&gt;
  &lt;Redirect from=<span style="color: #2544bb;">'/users/:id'</span> to=<span style="color: #2544bb;">'/users/profile/:id'</span>/&gt;
  &lt;Route path=<span style="color: #2544bb;">'/users/profile/:id'</span>&gt;
    &lt;Profile /&gt;
  &lt;/Route&gt;
&lt;/Switch&gt;
</pre>
</div>
<p>
其它的参数会被忽略掉。 <b>注意：</b> 只能用在 <code>&lt;Switch&gt;</code> 中的包含路径。
</p></li>
<li><code>exact: bool</code> 精确匹配，等价于 Route.exact
<b>注意：</b> 与 <code>from</code> 结合使用的时候，只能用 <code>&lt;Switch&gt;</code> 中包含的路径。</li>
<li><code>strict: bool</code> 严格匹配，等价于 Route.strict</li>
<li><code>sensitive: bool</code> 大小写敏感匹配，等价于 Route.sensitive</li>
</ul>
</div>
</div>

<div id="outline-container-orgf78d2a6" class="outline-3">
<h3 id="orgf78d2a6"><span class="section-number-3">2.8.</span> <code>&lt;Route&gt;</code></h3>
<div class="outline-text-3" id="text-2-8">
<p>
Route 可能是 React Router 中最需要理解和学习的组件。它的职责是当它的路径和当前 URL 相匹配的时候，显示 UI。
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5317ac;">import</span> React from <span style="color: #2544bb;">"react"</span>;
<span style="color: #5317ac;">import</span> ReactDOM from <span style="color: #2544bb;">"react-dom"</span>;
<span style="color: #5317ac;">import</span> <span style="color: #000000;">{</span> BrowserRouter as Router, Route <span style="color: #000000;">}</span> from <span style="color: #2544bb;">"react-router-dom"</span>;

ReactDOM.render<span style="color: #000000;">(</span>
  <span style="color: #a8007f;">&lt;</span><span style="color: #721045;">Router</span><span style="color: #a8007f;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">    </span><span style="color: #a8007f;">&lt;</span><span style="color: #721045;">div</span><span style="color: #a8007f;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">      </span><span style="color: #a8007f;">&lt;</span><span style="color: #721045;">Route</span> <span style="color: #00538b;">exact</span> <span style="color: #00538b;">path</span>=<span style="color: #2544bb;">"/"</span><span style="color: #a8007f;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">        </span><span style="color: #a8007f;">&lt;</span><span style="color: #721045;">Home</span> /<span style="color: #a8007f;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">      </span><span style="color: #a8007f;">&lt;</span>/<span style="color: #721045;">Route</span><span style="color: #a8007f;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">      </span><span style="color: #a8007f;">&lt;</span><span style="color: #721045;">Route</span> <span style="color: #00538b;">path</span>=<span style="color: #2544bb;">"/news"</span><span style="color: #a8007f;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">        </span><span style="color: #a8007f;">&lt;</span><span style="color: #721045;">NewsFeed</span> /<span style="color: #a8007f;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">      </span><span style="color: #a8007f;">&lt;</span>/<span style="color: #721045;">Route</span><span style="color: #a8007f;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">    </span><span style="color: #a8007f;">&lt;</span>/<span style="color: #721045;">div</span><span style="color: #a8007f;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">  </span><span style="color: #a8007f;">&lt;</span>/<span style="color: #721045;">Router</span><span style="color: #a8007f;">&gt;</span>,
  node
<span style="color: #000000;">)</span>;
</pre>
</div>

<p>
推荐 <code>&lt;Route&gt;</code> 渲染的方法是使用子元素，就上面这样。但事实上，还有一些其它的方法来渲染。这些方法主要是为了兼容 hook 引入之前路由构建的应用程序。
</p>

<ul class="org-ul">
<li><code>&lt;Route component&gt;</code></li>
<li><code>&lt;Route render&gt;</code></li>
<li><code>&lt;Route children&gt; function</code></li>
</ul>

<p>
你应该在 Route 上只使用上面的其中一个。上面三个渲染方法都会传递相同的 route props:
</p>

<ul class="org-ul">
<li><code>match</code></li>
<li><code>location</code></li>
<li><code>history</code></li>
</ul>

<p>
<b>component</b>
</p>

<p>
一个 React 组件：
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5317ac;">import</span> React from <span style="color: #2544bb;">"react"</span>;
<span style="color: #5317ac;">import</span> ReactDOM from <span style="color: #2544bb;">"react-dom"</span>;
<span style="color: #5317ac;">import</span> <span style="color: #000000;">{</span> BrowserRouter as Router, Route <span style="color: #000000;">}</span> from <span style="color: #2544bb;">"react-router-dom"</span>;

<span style="color: #505050;">// </span><span style="color: #505050;">All route props (match, location and history) are available to User</span>
<span style="color: #5317ac;">function</span> <span style="color: #721045;">User</span><span style="color: #000000;">(</span><span style="color: #00538b;">props</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #5317ac;">return</span> <span style="color: #a8007f;">&lt;</span><span style="color: #721045;">h1</span><span style="color: #a8007f;">&gt;</span><span style="color: #000000; background-color: #ffffff;">Hello </span><span style="color: #a8007f;">{</span>props.match.params.username<span style="color: #a8007f;">}</span><span style="color: #000000; background-color: #ffffff;">!</span><span style="color: #a8007f;">&lt;</span>/<span style="color: #721045;">h1</span><span style="color: #a8007f;">&gt;</span>;
<span style="color: #000000;">}</span>

ReactDOM.render<span style="color: #000000;">(</span>
  <span style="color: #a8007f;">&lt;</span><span style="color: #721045;">Router</span><span style="color: #a8007f;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">    </span><span style="color: #a8007f;">&lt;</span><span style="color: #721045;">Route</span> <span style="color: #00538b;">path</span>=<span style="color: #2544bb;">"/user/:username"</span> <span style="color: #00538b;">component</span>=<span style="color: #005f88;">{</span>User<span style="color: #005f88;">}</span> /<span style="color: #a8007f;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">  </span><span style="color: #a8007f;">&lt;</span>/<span style="color: #721045;">Router</span><span style="color: #a8007f;">&gt;</span>,
  node
<span style="color: #000000;">)</span>;
</pre>
</div>

<p>
当使用组件（而不是 <code>render</code> 和 <code>children</code> 的时候），router 根据给定的组件使用 <code>React.createElement</code> 创建一个新的 React 元素。
也就是说，如果向组件 prop 提供了一个内联函数，那么会在每次渲染的时候创建一个新的组件。会导致现有的组件卸载和新组件的装载，而不仅仅是更新现有组件。
使用内联函数渲染时，请使用 <code>render</code> 或者 <code>children</code> 。
</p>

<p>
<b>render: func</b>
</p>

<p>
可以方便的内联渲染和包装，无需上面说的不必要的重新安装。当匹配路径的时候，你可以传入一个函数。渲染函数与 component 具有相同的属性（match，location，history）。
</p>

<div class="org-src-container">
<pre class="src src-js"><span style="color: #5317ac;">import</span> React from <span style="color: #2544bb;">"react"</span>;
<span style="color: #5317ac;">import</span> ReactDOM from <span style="color: #2544bb;">"react-dom"</span>;
<span style="color: #5317ac;">import</span> <span style="color: #000000;">{</span> BrowserRouter as Router, Route <span style="color: #000000;">}</span> from <span style="color: #2544bb;">"react-router-dom"</span>;

<span style="color: #505050;">// </span><span style="color: #505050;">convenient inline rendering</span>
ReactDOM.render<span style="color: #000000;">(</span>
  <span style="color: #a8007f;">&lt;</span><span style="color: #721045;">Router</span><span style="color: #a8007f;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">    </span><span style="color: #a8007f;">&lt;</span><span style="color: #721045;">Route</span> <span style="color: #00538b;">path</span>=<span style="color: #2544bb;">"/home"</span> <span style="color: #00538b;">render</span>=<span style="color: #005f88;">{</span><span style="color: #904200;">()</span> =&gt; <span style="color: #904200;">&lt;</span><span style="color: #721045;">div</span><span style="color: #904200;">&gt;</span><span style="color: #000000; background-color: #ffffff;">Home</span><span style="color: #904200;">&lt;</span>/<span style="color: #721045;">div</span><span style="color: #904200;">&gt;</span><span style="color: #005f88;">}</span> /<span style="color: #a8007f;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">  </span><span style="color: #a8007f;">&lt;</span>/<span style="color: #721045;">Router</span><span style="color: #a8007f;">&gt;</span>,
  node
<span style="color: #000000;">)</span>;

<span style="color: #505050;">// </span><span style="color: #505050;">wrapping/composing</span>
<span style="color: #505050;">// </span><span style="color: #505050;">You can spread routeProps to make them available to your rendered Component</span>
<span style="color: #5317ac;">function</span> <span style="color: #721045;">FadingRoute</span><span style="color: #000000;">(</span><span style="color: #a8007f;">{</span> component: Component, ...rest <span style="color: #a8007f;">}</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #5317ac;">return</span> <span style="color: #a8007f;">(</span>
    <span style="color: #005f88;">&lt;</span><span style="color: #721045;">Route</span>
      <span style="color: #904200;">{</span>...rest<span style="color: #904200;">}</span>
      <span style="color: #00538b;">render</span>=<span style="color: #904200;">{</span>routeProps =&gt; <span style="color: #7f10d0;">(</span>
        <span style="color: #006800;">&lt;</span><span style="color: #721045;">FadeIn</span><span style="color: #006800;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">          </span><span style="color: #006800;">&lt;</span><span style="color: #721045;">Component</span> <span style="color: #b60000;">{</span>...routeProps<span style="color: #b60000;">}</span> /<span style="color: #006800;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">        </span><span style="color: #006800;">&lt;</span>/<span style="color: #721045;">FadeIn</span><span style="color: #006800;">&gt;</span>
      <span style="color: #7f10d0;">)</span><span style="color: #904200;">}</span>
    /<span style="color: #005f88;">&gt;</span>
  <span style="color: #a8007f;">)</span>;
<span style="color: #000000;">}</span>

ReactDOM.render<span style="color: #000000;">(</span>
  <span style="color: #a8007f;">&lt;</span><span style="color: #721045;">Router</span><span style="color: #a8007f;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">    </span><span style="color: #a8007f;">&lt;</span><span style="color: #721045;">FadingRoute</span> <span style="color: #00538b;">path</span>=<span style="color: #2544bb;">"/cool"</span> <span style="color: #00538b;">component</span>=<span style="color: #005f88;">{</span>Something<span style="color: #005f88;">}</span> /<span style="color: #a8007f;">&gt;</span>
<span style="color: #000000; background-color: #ffffff;">  </span><span style="color: #a8007f;">&lt;</span>/<span style="color: #721045;">Router</span><span style="color: #a8007f;">&gt;</span>,
  node
<span style="color: #000000;">)</span>;
</pre>
</div>

<p>
<b>警告：</b> <code>&lt;Route component&gt;</code> 优先级高于 <code>&lt;Route render&gt;</code> ，所以不要同时使用。
</p>

<p>
<b>children: func</b>
</p>

<p>
TODO，看不懂。
</p>

<p>
支持的参数：
</p>

<ul class="org-ul">
<li><code>path: string | string[]</code></li>
</ul>

<p>
<a href="https://reacttraining.com/react-router/web/api/Route/path-string-string">https://reacttraining.com/react-router/web/api/Route/path-string-string</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="postamble">First created: 2019-11-27 14:41:40 <br />Last updated: 2022-08-23 Tue 18:22 <br />Power by <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.1 (<a href="https://orgmode.org">Org</a> mode 9.5.4)</p>
</div>
</body>
</html>
