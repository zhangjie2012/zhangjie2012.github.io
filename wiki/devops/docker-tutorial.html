<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-08-23 Tue 18:44 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Docker 学习笔记</title>
<meta name="author" content="DESKTOP-ZHJ" />
<meta name="description" content="Keep It Simple, Stupid" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="/static/site.css" />
<script>
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
// @license-end
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Docker 学习笔记</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org04a5898">1. Docker 简介</a></li>
<li><a href="#org9fc936c">2. 基本概念</a>
<ul>
<li><a href="#org56a5102">2.1. 镜像（Image）</a></li>
<li><a href="#org8b987f1">2.2. 容器（container）</a></li>
<li><a href="#org4b015ca">2.3. Docker Registry</a></li>
</ul>
</li>
<li><a href="#orga0dfdb2">3. 安装 Docker</a>
<ul>
<li><a href="#org8ec1bb2">3.1. 设置加速器</a></li>
</ul>
</li>
<li><a href="#orga4ca143">4. 镜像操作</a>
<ul>
<li><a href="#org857805e">4.1. 理解镜像构成</a></li>
</ul>
</li>
<li><a href="#org7ba7086">5. 镜像构建</a>
<ul>
<li><a href="#org13727c8">5.1. Dockerfile 格式</a></li>
<li><a href="#org2370194">5.2. 注意事项</a></li>
</ul>
</li>
<li><a href="#orgdf6dafc">6. 操作 Docker 容器</a>
<ul>
<li><a href="#org3846840">6.1. 启动容器</a></li>
<li><a href="#org1793698">6.2. 终止容器</a></li>
<li><a href="#org232cdcf">6.3. 操作容器</a>
<ul>
<li><a href="#org5907a35">6.3.1. 进入容器</a></li>
<li><a href="#org4abe5e6">6.3.2. 查看资源占用</a></li>
</ul>
</li>
<li><a href="#orgfe5f2af">6.4. 删除容器</a></li>
<li><a href="#org62b0040">6.5. 导入和导出容器</a></li>
</ul>
</li>
<li><a href="#org9a3a4d7">7. 访问仓库</a>
<ul>
<li><a href="#org8be21c7">7.1. Docker Hub</a></li>
<li><a href="#org177d577">7.2. 私有仓库</a></li>
</ul>
</li>
<li><a href="#orgbe95adc">8. 数据管理</a>
<ul>
<li><a href="#orgf0f02ff">8.1. 数据卷</a></li>
<li><a href="#orgabcfd67">8.2. 挂载主机目录</a></li>
</ul>
</li>
<li><a href="#orgd07923a">9. 容器网络</a>
<ul>
<li><a href="#org3705ac2">9.1. 外部访问容器</a></li>
<li><a href="#orgc42a95f">9.2. 容器互联</a></li>
<li><a href="#orgdf11b1b">9.3. 配置 DNS</a></li>
</ul>
</li>
<li><a href="#org3b30e30">10. 常用的镜像库</a>
<ul>
<li><a href="#orga8fafd3">10.1. BusyBox</a></li>
<li><a href="#org11bb519">10.2. Apline Linux</a></li>
</ul>
</li>
<li><a href="#org187d01d">11. 实践</a>
<ul>
<li><a href="#org2236b0b">11.1. ENTRYPOINT 和 CMD 的区别</a></li>
<li><a href="#org13f8308">11.2. 端口暴露、-p 和 -P 的区别</a></li>
<li><a href="#org7e0af2b">11.3. Docker 如何跟随系统启动？</a></li>
<li><a href="#org321996e">11.4. 对已有的容器（重新）添加端口映射</a></li>
<li><a href="#org80d913f">11.5. ADD 和 COPY 的区别</a></li>
</ul>
</li>
<li><a href="#org5be2af6">12. FAQ</a>
<ul>
<li><a href="#org471b6f9">12.1. 如何获取机器容器 IP</a></li>
<li><a href="#org7216ba5">12.2. docker 作为 crontab 命令时报错, <code>Error The input device is not a TTY</code></a></li>
</ul>
</li>
<li><a href="#orgbdc714a">13. 参考资料</a></li>
</ul>
</div>
</div>

<div id="outline-container-org04a5898" class="outline-2">
<h2 id="org04a5898"><span class="section-number-2">1.</span> Docker 简介</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="https://www.docker.com/">Docker</a> 是基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。也称之为容器。
</p>

<p>
VM vs Docker：VM 需要运行一个完整的操作系统，再在系统上运行应用进程；而容器的应用进程直接运行于宿主机的内核，所以相比 VM 更为轻便。
</p>


<div id="org1ff6e08" class="figure">
<p><img src="https://wiki-1252349778.cos.ap-shanghai.myqcloud.com/2018/whatisdocker.png" alt="whatisdocker.png" />
</p>
</div>

<p>
Docker 的优势：
</p>

<ul class="org-ul">
<li>更好的利用系统资源，因为少去了虚拟操作系统的开销，相比 VM 可以运行更多数量的应用</li>
<li>更快的启动时间</li>
<li>一致的运行环境，Docker 镜像提供除内核之外的完整运行环境，确保了应用运行环境一致性</li>
<li>持续交付和部</li>
<li>更轻松的迁移，Docker 几乎可以运行于任意环境，物理机、虚拟机、公有云、私有云等，运行结果是一致的</li>
<li>更轻松的维护和扩展，分层存储和镜像技术，使得易复用</li>
</ul>
</div>
</div>

<div id="outline-container-org9fc936c" class="outline-2">
<h2 id="org9fc936c"><span class="section-number-2">2.</span> 基本概念</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org56a5102" class="outline-3">
<h3 id="org56a5102"><span class="section-number-3">2.1.</span> 镜像（Image）</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。
</p>
</div>
</div>

<div id="outline-container-org8b987f1" class="outline-3">
<h3 id="org8b987f1"><span class="section-number-3">2.2.</span> 容器（container）</h3>
<div class="outline-text-3" id="text-2-2">
<p>
镜像是静态的定义，容器是镜像运行之后的实例。容器可以被创建、启动、停止、删除等。容器的本质是进程，但与直接在宿主机运行的进程不同，它是一套隔离的环境（独立的命名空间）：有自己的文件系统、网络配置、进程空间，使用起来就像是一个独立的宿主系统一样。
</p>

<p>
容器也使用分层存储，容器运行时，镜像时基础层，在其上创建一个当前容器的存储层，称之为容器运行时读写而准备的存储层为容器存储层。它的生命周期和容器一样，因此保存于容器存储层的信息都会随容器的删除而丢失。
</p>

<p>
按照 Docker 最佳实践的要求，容器不应该像其存储层写入任何数据，保持无状态化。如果有写入操作，应该使用数据卷（Volumn）、或者绑定宿主目录，这些位置的读写将跳过容器存储层，直接对宿主机发生读写，性能和稳定性更高。
</p>
</div>
</div>

<div id="outline-container-org4b015ca" class="outline-3">
<h3 id="org4b015ca"><span class="section-number-3">2.3.</span> Docker Registry</h3>
<div class="outline-text-3" id="text-2-3">
<pre class="example">
Registry =&gt; Repositories =&gt; Tags = Image
</pre>

<p>
仓库是集中存储和分发镜像的服务。一个 Registry 可以包含多个仓库（Repository），每个仓库可以包含多个标签（Tag），每个标签对应一个镜像（Image）。
</p>

<p>
通常一个仓库对应一个软件，Tag 对应软件的不同版本镜像。可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 来指定具体软件版本的镜像，如果不给定标签，默认为 <code>lastest</code> 标签。
</p>
</div>
</div>
</div>

<div id="outline-container-orga0dfdb2" class="outline-2">
<h2 id="orga0dfdb2"><span class="section-number-2">3.</span> 安装 Docker</h2>
<div class="outline-text-2" id="text-3">
<p>
直接用系统的包管理器安装的版本一般比较低，推荐设置源之后，手动安装，具体可以查看 Docker 官方说明：
</p>

<ul class="org-ul">
<li>Ubuntu：<a href="https://docs.docker.com/engine/install/ubuntu/">https://docs.docker.com/engine/install/ubuntu/</a></li>
</ul>
</div>

<div id="outline-container-org8ec1bb2" class="outline-3">
<h3 id="org8ec1bb2"><span class="section-number-3">3.1.</span> 设置加速器</h3>
<div class="outline-text-3" id="text-3-1">
<p>
推荐 Azure 的源，<a href="https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md">AKS on Azure China Best Practices</a>
</p>

<p>
修改配置 <code>/etc/docker/daemon.json</code> ：
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #000000;">{</span>
    <span style="color: #2544bb;">"registry-mirrors"</span>: <span style="color: #a8007f;">[</span>
        <span style="color: #2544bb;">"https://dockerhub.azk8s.cn"</span>
    <span style="color: #a8007f;">]</span>
<span style="color: #000000;">}</span>
</pre>
</div>

<p>
重启： <code>service docker restart</code> ，查看信息： <code>docker info</code> 。
</p>

<p>
其他加速器：
</p>

<ul class="org-ul">
<li>中科大：<a href="https://mirrors.ustc.edu.cn/help/dockerhub.html">https://mirrors.ustc.edu.cn/help/dockerhub.html</a></li>
<li>daocloud: <a href="https://www.daocloud.io/mirror">https://www.daocloud.io/mirror</a></li>
</ul>


<p>
<code>WSL Ubuntu 22.04</code> 启动 docker 报错：
</p>

<pre class="example">
failed to start daemon: Error initializing network controller: error obtaining controller instance: unable to add return
rule in DOCKER-ISOLATION-STAGE-1 chain:  (iptables failed: iptables --wait -A DOCKER-ISOLATION-STAGE-1 -j RETURN:
iptables v1.8.7     (nf_tables):  RULE_APPEND failed (No such file or directory): rule in chain DOCKER-ISOLATION-STAGE-1
</pre>

<p>
解决办法<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>：
</p>

<pre class="example">
sudo update-alternatives --set iptables /usr/sbin/iptables-legacy
sudo update-alternatives --set ip6tables /usr/sbin/ip6tables-legacy
</pre>
</div>
</div>
</div>

<div id="outline-container-orga4ca143" class="outline-2">
<h2 id="orga4ca143"><span class="section-number-2">4.</span> 镜像操作</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>获取镜像: <code>docker pull</code></li>
<li>运行镜像: <code>docker run -it --rm image:tag bash</code>
<ul class="org-ul">
<li><code>-it</code>: <code>-i</code> 交互式操作， <code>-t</code> 指终端</li>
<li><code>--rm</code>: 容器退出后删除，否则需要手动执行 <code>docker rm</code></li>
<li><code>bash</code>: 放在镜像最后的是命令</li>
</ul></li>
<li>列出本地镜像: <code>docker image ls</code> 或者 <code>docker images</code> ，内容分别对应: 仓库名、标签、镜像ID、创建时间、所占用的空间，镜像 ID 是镜像的唯一标识
<ul class="org-ul">
<li><code>docker image ls -a</code> 显示所有镜像（包括中间层镜像），顶层的镜像会依赖中间层镜像，当没有顶层镜像依赖时，中间层会连带删除</li>
<li><code>docker images ubuntu</code> 可以做镜像筛选，使用 <code>-f</code> / <code>--filter</code> 选项做更为复杂的筛选，比如 <code>since=mongo:3.2</code> 表示 3.2 之后建立的镜像</li>
<li><code>docker image ls -q</code> 只显示镜像 ID，在批量删除镜像时很有用</li>
</ul></li>
<li><code>docker system df</code>: 查看镜像、容器、数据卷所占用的空间</li>
<li><code>docker image ls -f dangling=true</code> 显示所有的悬挂镜像（dangling）， <code>docker image prune</code> 可以删掉他们</li>
<li>删除本地镜像: <code>docker image rm</code> 或者 <code>docker rmi</code>
<ul class="org-ul">
<li><code>docker rmi $(docker image ls -q redis)</code>: 批量删除所有的 redis 镜像</li>
</ul></li>
</ul>
</div>

<div id="outline-container-org857805e" class="outline-3">
<h3 id="org857805e"><span class="section-number-3">4.1.</span> 理解镜像构成</h3>
<div class="outline-text-3" id="text-4-1">
<p>
<code>docker diff</code> 可以查看容器被修改的文件（也就是修改了容器的存储层），Docker 提供了 <code>docker commit</code> 命令，用于在原有镜像的基础上，叠加修改部分，构成新的镜像。 提交命令有点像 <code>git commit</code> ，具体可使用 <code>docker commit --help</code> 来查看格式和参数。
<code>docker history</code> 可以查看历史记录。
</p>

<p>
commit 可能会把一些无关紧要的文件（安装包、构建临时文件等）全部加进来，处理的不好，会导致镜像臃肿。分层机制是对前一层进行追加，而不是改动，所以每一次 commit 都一定会使得镜像变大。
</p>

<p>
更好的方式，是使用 <code>Dockerfile</code> 来定制镜像，而不是 commit。
</p>
</div>
</div>
</div>

<div id="outline-container-org7ba7086" class="outline-2">
<h2 id="org7ba7086"><span class="section-number-2">5.</span> 镜像构建</h2>
<div class="outline-text-2" id="text-5">
<p>
镜像构建需要引入 <code>Dockerfile</code> 文件，Dockerfile 是一个文本文件，包含了一条条的指令（instruction），一条指令构建一层，因此每一层指令的内容，就是描述该层如何构建。
有了 Dockerfile 之后使用 <code>docker build</code> 指令来构建镜像。 <code>build</code> 会自动选择当前目录下名为 Dockerfile 的文件，也可以通过 <code>-f</code> 选项来指定 Dockerfile。
build 不光需要 Dockerfile，还需要指定构建的上下文（context）目录，对于上下文的理解，可以参考注意事项中的说明。
</p>

<p>
构建时通过 <code>-t</code> 选项指定镜像仓库和标签，一个典型的例子为：
</p>

<div class="org-src-container">
<pre class="src src-shell">docker build -t jerryzhang/app:v1.0 .
</pre>
</div>

<p>
表示镜像仓库和名称为 <code>jerryzhang/app</code> ，标签为 <code>v1.0</code> ，上下文为当前目录。
</p>
</div>

<div id="outline-container-org13727c8" class="outline-3">
<h3 id="org13727c8"><span class="section-number-3">5.1.</span> Dockerfile 格式</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Dockerfile 每一行由指令和参数两部分组成: <code>INSTRUCTION arguments</code> ，指令不缺分大小写，但一般用大写。常用的指令即说明如下：
</p>

<ul class="org-ul">
<li><code>FROM</code> 指定基础镜像，FROM 是 Dockerfile 的第一条指令，也是必备的指令； <code>scratch</code> 是一个特殊的镜像，表示一个空白镜像，不以任何系统为基础，直接可将执行文件复制进镜像（不常见），使用 Go 语言开发通常会使用这种方式来制作镜像。</li>
<li><code>RUN</code> 执行命令，一般包括两种形式：
<ul class="org-ul">
<li><code>RUN &lt;CMD&gt;</code> Shell 格式，默认是 <code>/bin/sh -c</code> 来执行</li>
<li><code>RUN ["exe", "param1", "param2"]</code> exec 格式</li>
</ul></li>
<li><code>COPY</code> 复制文件，将构建上下文目录中的源路径文件拷贝到新一层镜像的目标路径中</li>
<li><code>ADD</code> 和 <code>COPY</code> 的功能基本一致，但是增加一些额外的功能
<ul class="org-ul">
<li>源路径可以是一个 <code>URL</code> ，如果是 URL ，Docker 引擎会试图去下载这个链接的文件到目标路径，然后把权限设置为 <code>600</code> ；如果是压缩包，需要额外解压，比较麻烦，不如使用 <code>RUN</code> 命令，但如果是 <code>tar</code> 压缩文件，格式为 <code>gzip~，~bzip2</code> 以及 <code>xz</code> 的情况下， <code>ADD</code> 会自动解压到目标路径去</li>
<li>根据 Dockerfile 最佳实践文档的要求，尽可能的使用 <code>COPY</code> 来拷贝文件。只有需要自动解压这种需求，才使用 <code>ADD</code> 。</li>
</ul></li>
<li><code>CMD</code> 和 <code>RUN</code> 类似，也可以有 <code>shell</code> 和 <code>exec</code> 两种格式，使用 <code>ENTRYPOINT</code> 指令之后, <code>CMD</code> 指定具体的参数。
<ul class="org-ul">
<li><code>CMD</code> 用于指定容器主进程的启动命令</li>
<li>运行时，可以指定新的命令来代替镜像设置中的默认命令，比如 <code>docker run -it --rm ubuntu cat /etc/os-release</code> 就是使用 <code>cat /etc/os-release</code> 来代替默认的 <code>/bin/bash</code> 命令</li>
<li>一般推荐使用 <code>exec</code> 格式（会被解析为 JSON 数组，因此一定要使用双引号，而不是单引号）</li>
<li>一个 Dockerfile 中只能有一个 CMD 命令，多个命令是只有最后一个才能生效</li>
</ul></li>
<li><code>ENTRYPOINT</code> 和 <code>CMD</code> 指令格式一样，分为 <code>shell</code> 和 <code>exec</code> 两种。而且目的也相同，指定容器的启动程序及参数，一旦指定了 <code>ENTRYPOINT</code> 之后，~CMD~ 的内容将会作为参数传给 <code>ENTRYPOINT</code> 而不是直接运行命令，一般情况下，使用 <code>CMD</code> 即可。 <code>ENTRYPOINT</code> 可以被 <code>docker run</code> 指令中的 <code>-entrypoint</code> 选项指定的指令覆盖（不推荐这么用）。</li>
<li><code>ENV</code> 设置环境变量，环境变量设置之后立即生效，后面的指令可以直接使用，设置方法有：
<ul class="org-ul">
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul></li>
<li><code>ARG</code> 构建参数，和 <code>ENV</code> 效果相同，都是设置环境变量，不同的是，ARG 所设置的环境变量只有在构建时期才生效，在容器运行时不存在</li>
<li><code>VOLUME</code> 定义匿名卷，向匿名挂载写入的信息都不会记录进容器存储层，从而保证的容器的无状态化。在运行时，可以通过 <code>-v</code> 参数覆盖掉匿名卷</li>
<li><code>EXPOSE</code> 暴露端口，声明运行时，容器提供服务端口（只是一个声明，运行时并不是因为声明就会开启这个端口的服务），好处是：
<ul class="org-ul">
<li>帮助镜像使用者理解这个镜像服务的守护端口，方便配置映射</li>
<li>运行时使用随机端口映射时（ <code>docker run -P</code> ），会自动随机映射 <code>EXPOSE</code> 端口</li>
<li><code>EXPOSE</code> 容器和 <code>-p</code> 搞混，具体区别看下面的「端口暴露、-p 和 -P 的区别」</li>
</ul></li>
<li><code>WORKDIR</code> 指定工作目录，在 Dockerfile 中连续两行命令的执行环境不同（分层存储），像 <code>cd</code> 这样的命令连续两行写将没有任何作用，所以想要改变以后各层的工作目录的位置，应该使用 <code>WORDDIR</code> 命令</li>
<li><code>USER</code> 指定当前用户，和 <code>WORKDIR</code> 相似，改变环境状态并影响以后的层。~USER~ 只是做一个切换用户的操作，用户必须是提前创建好的，否则无法切换
<ul class="org-ul">
<li>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，不要使用 <code>su</code> 或者 <code>sudo</code> ，建议使用 <code>gosu</code></li>
</ul></li>
<li><code>HEALTHCHECK</code> 健康检查，同样支持 <code>shell</code> 和 <code>exec</code> 两种格式。命令的返回值决定了该次健康检查的成功与否，0 成功，1 失败，2 保留（不要使用保留）。告诉 Docker 如何判断容器状态是否正常，指定了 <code>HEATHCHECK</code> 指令之后，启动时状态为 <code>starting</code> ，检查成功状态为 <code>health</code> ，连续一定次数失败，则会变为 <code>unhealthy</code> 。
<ul class="org-ul">
<li><code>--interval=&lt;间隔&gt;</code> ：两次健康检查的间隔，默认为 30 秒</li>
<li><code>--timeout=&lt;时长&gt;</code> ：命令超时时间，超过这个时间，本次健康检查就会被视为失败</li>
<li><code>--retries=&lt;次数&gt;</code> ：指定多少次失败之后，容器状态被视为 <code>unhealthy</code> ，默认 3 次</li>
</ul></li>
<li><code>LABEL</code> 为镜像添加元数据（标签），是一个 key-value，可用来设置 version、description 等信息，多个 LABEL 数据时，建议合并起来。通过 <code>docker inspect</code> 查看镜像相关的标签信息</li>
</ul>

<p>
因为 Docker 中的每一个指令都会建立一层镜像，所以尽可能把命令合并成一个串联的命令 <code>&amp;&amp;</code> 。
</p>
</div>
</div>

<div id="outline-container-org2370194" class="outline-3">
<h3 id="org2370194"><span class="section-number-3">5.2.</span> 注意事项</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>Docker 在运行时分为 Docker 引擎（服务端的守护进程）和客户端工具，Docker 引擎提供了一组 REST API， <code>docker</code> 命令这样的客户端工具，实际上是通过 API 和 docker 引擎进行交互，从而完成各种功能。构建镜像时， <code>COPY</code> 这种指令并非是在本地构建，而是在服务端，所以在构建镜像时，用户需要提供镜像上下文的路径（ <code>docker build</code> 需要指定的目录就是上下文路径），Dockerfile 中指令中的路径不可以超过上下文，否则将无法工作；</li>
<li>容器和虚拟机不同，容器中的应用都应该是以 <span class="underline">前台</span> 的方式运行的，容器没有后台的概念。对于容器而言，容器的启动进程就是容器的应用进程，容器就是为了主进程而存在的，主进程退出了，容器就失去了存在意义。所以 <code>CMD service nginx start</code> 容器执行之后就立刻退出了（因为指令运行结束了）。正确的做法是关闭 nginx 的后台运行， <code>CMD ["nginx", "-g", "daemon off;"]</code> ；</li>
<li>因为 Docker 是在前台运行的，随着内部进程的停止而停止，所以一个 <code>Dockerfile</code> 中必须要指定 <code>CMD</code> 或者 <code>ENTRYPOINT</code> 中的一个（用来启动命令进程）；</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgdf6dafc" class="outline-2">
<h2 id="orgdf6dafc"><span class="section-number-2">6.</span> 操作 Docker 容器</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org3846840" class="outline-3">
<h3 id="org3846840"><span class="section-number-3">6.1.</span> 启动容器</h3>
<div class="outline-text-3" id="text-6-1">
<p>
启动容器分为，直接基于镜像新建一个容器 和 将终止状态（stoped）的容器重新启动，将终止状态的容器启动只需要 <code>docker container start</code> 可简写为 <code>docker start</code> 。
</p>

<p>
<code>docker run</code> 用于创建并启动容器，一般会使用 <code>-t</code> 和 <code>-i</code> 选项， <code>-t</code> 选项让 Docker 分配一个微终端（pseudo-tty）并绑定到容器的标准输入中， <code>-i</code> 让容器的标准输入保持打开。Docker 后台运行的标准操作包括：
</p>

<ul class="org-ul">
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>

<p>
其它参数：
</p>

<ul class="org-ul">
<li><code>-d</code> 选项可以让 Docker 以后台的方式运行（daemon），输出结果不再会输出到当前宿主机下（可以通过 <code>docker logs</code> 来查看）。</li>
</ul>
</div>
</div>

<div id="outline-container-org1793698" class="outline-3">
<h3 id="org1793698"><span class="section-number-3">6.2.</span> 终止容器</h3>
<div class="outline-text-3" id="text-6-2">
<p>
<code>docker container stop</code> （可简写为 <code>docker stop</code> ）用来终止容器运行。终止的容器通过 <code>docker start</code> 可重新启动它。
</p>
</div>
</div>

<div id="outline-container-org232cdcf" class="outline-3">
<h3 id="org232cdcf"><span class="section-number-3">6.3.</span> 操作容器</h3>
<div class="outline-text-3" id="text-6-3">
</div>
<div id="outline-container-org5907a35" class="outline-4">
<h4 id="org5907a35"><span class="section-number-4">6.3.1.</span> 进入容器</h4>
<div class="outline-text-4" id="text-6-3-1">
<p>
后台运行的容器，可通过 <code>attach</code> 或者 <code>exec</code> 命令进入容器操作。推荐使用 <code>exec</code> ，因为从 attach 的容器中退出会导致容器的退出，而 exec 不会。
</p>

<p>
<code>exec</code> 通常和 <code>-i</code> <code>-t</code> 一起使用，提供交互功能。比如: <code>docker exec -it mongo bash</code> 。
</p>
</div>
</div>

<div id="outline-container-org4abe5e6" class="outline-4">
<h4 id="org4abe5e6"><span class="section-number-4">6.3.2.</span> 查看资源占用</h4>
<div class="outline-text-4" id="text-6-3-2">
<div class="org-src-container">
<pre class="src src-shell">docker stats <span style="color: #000000;">[</span>OPTIONS<span style="color: #000000;">]</span> <span style="color: #000000;">[</span>CONTAINER...<span style="color: #000000;">]</span>
</pre>
</div>

<p>
<code>docker stat</code> 用来实时查看容器资源占用统计， <code>--format</code> 参数用来自定义显示格式， <code>--no-stream</code> 禁止不断刷新，只显示一次。具体看 <a href="https://docs.docker.com/engine/reference/commandline/stats/#description">这里</a>。
</p>
</div>
</div>
</div>

<div id="outline-container-orgfe5f2af" class="outline-3">
<h3 id="orgfe5f2af"><span class="section-number-3">6.4.</span> 删除容器</h3>
<div class="outline-text-3" id="text-6-4">
<p>
<code>docker container rm</code> （可简写为 <code>docker rm</code> ）用来删除处于终止状态的容器，如果容器在运行过程中，需要指定 <code>-f</code> 参数，Docker 会发送 <code>SIGKILL</code> 信号给容器。
</p>

<p>
<code>docker container prune</code> 可清理掉所有处于停止状态的命令。
</p>
</div>
</div>

<div id="outline-container-org62b0040" class="outline-3">
<h3 id="org62b0040"><span class="section-number-3">6.5.</span> 导入和导出容器</h3>
<div class="outline-text-3" id="text-6-5">
<ul class="org-ul">
<li><code>docker export</code>: 把 docker 容器快照导出到文件中</li>
<li><code>docker import</code>: 把快照文件导入为镜像（注意是镜像，而非容器）</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org9a3a4d7" class="outline-2">
<h2 id="org9a3a4d7"><span class="section-number-2">7.</span> 访问仓库</h2>
<div class="outline-text-2" id="text-7">
<p>
仓库（Repository）是集中存放镜像的，注册服务器（Registry）是管理仓库的具体服务器，一个服务器可以有多个仓库，而仓库可以理解成 Registry 中具体的项目或者目录。
</p>
</div>

<div id="outline-container-org8be21c7" class="outline-3">
<h3 id="org8be21c7"><span class="section-number-3">7.1.</span> Docker Hub</h3>
<div class="outline-text-3" id="text-7-1">
<p>
<a href="https://hub.docker.com/">Docker Hub</a> 是 Docker 官方维护的公共仓库，涵盖了大部分需求。
</p>

<ul class="org-ul">
<li><code>docker login</code></li>
<li><code>docker logout</code></li>
<li><code>docker search</code>: 查找官方仓库中的镜像。搜索结果可以分为两类，一类是类似 <code>centos</code> 的镜像，通常被称为基础镜像或者根镜像。由 Docker 公司创建、验证、支持、提供。另外一种类似 <code>ansible/centos7-ansible</code> 是由 Docker 用户创建并维护的，带有用户名称前缀。查找的时候 <code>--filter=stars=N</code> 可以指定显示收藏数量为 N 以上的镜像。</li>
<li><code>docker pull</code>: 下载镜像到本地</li>
<li><code>docker push</code>: 推送镜像到 Docker Hub。</li>
</ul>
</div>
</div>

<div id="outline-container-org177d577" class="outline-3">
<h3 id="org177d577"><span class="section-number-3">7.2.</span> 私有仓库</h3>
<div class="outline-text-3" id="text-7-2">
<p>
Docker 官方提供了 <code>registry</code> 用于构建私有的镜像仓库。
</p>
</div>
</div>
</div>

<div id="outline-container-orgbe95adc" class="outline-2">
<h2 id="orgbe95adc"><span class="section-number-2">8.</span> 数据管理</h2>
<div class="outline-text-2" id="text-8">
<p>
容器中管理数据主要又两种方式：数据卷（Volumes）和挂载主机目录（Bind mounts），但其实挂载的数据目录也是数据卷的一种方式。
</p>
</div>

<div id="outline-container-orgf0f02ff" class="outline-3">
<h3 id="orgf0f02ff"><span class="section-number-3">8.1.</span> 数据卷</h3>
<div class="outline-text-3" id="text-8-1">
<p>
数据卷是一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：
</p>

<ul class="org-ul">
<li>允许在容器之间共享和重用</li>
<li>对数据卷的修改立马生效</li>
<li>对数据卷的更新，不会影响镜像</li>
<li>生命周期不跟随容器，容器删除了卷依然存在</li>
</ul>

<p>
常用命令：
</p>

<ul class="org-ul">
<li><code>docker volume create my-col</code>: 用于创建数据卷</li>
<li><code>docker volume rm my-col</code>: 删除数据卷</li>
<li><code>docker volume ls</code>: 查看所有的数据卷</li>
<li><code>docker volume inspect my-vol</code>: 查看数据卷的信息</li>
<li><code>docker inspect container</code>: 查看容器的卷信息，数据卷信息在 <code>Mounts</code> key 下面</li>
</ul>

<p>
<code>docker run</code> 使用 <code>--mount</code> 标记来将数据卷挂载到容器里，一次可以挂载多个卷。
</p>

<pre class="example">
docker run -d -P \
    --name web \
    # -v my-vol:/wepapp \
    --mount source=my-vol,target=/webapp \
    training/webapp \
    python app.py
</pre>

<p>
<code>--mount</code> 的 <code>source</code> <code>target</code> 的方式，可以简单的使用 <code>-v source:target</code> 的方式来实现。
</p>

<p>
注意：卷的生命周期和容器是独立的，删除容器不会影响挂载卷，如果需要删除容器的同时移除卷，可以在删除容器的时候使用 <code>docker rm -v</code> 命令。同样无主的数据卷可能占用很多空间，使用 <code>docker volume prune</code> 清理。
</p>
</div>
</div>

<div id="outline-container-orgabcfd67" class="outline-3">
<h3 id="orgabcfd67"><span class="section-number-3">8.2.</span> 挂载主机目录</h3>
<div class="outline-text-3" id="text-8-2">
<p>
Docker 允许挂载一个主机目录作为数据卷。区别仅在于 <code>source</code> 为主机目录，而不是通过 <code>docker volume create</code> 创建的卷。还允许将主机的一个文件挂载到容器中，方式相同，只不过 <code>source</code> 和 <code>target</code> 都是文件。
</p>
</div>
</div>
</div>

<div id="outline-container-orgd07923a" class="outline-2">
<h2 id="orgd07923a"><span class="section-number-2">9.</span> 容器网络</h2>
<div class="outline-text-2" id="text-9">
</div>
<div id="outline-container-org3705ac2" class="outline-3">
<h3 id="org3705ac2"><span class="section-number-3">9.1.</span> 外部访问容器</h3>
<div class="outline-text-3" id="text-9-1">
<p>
<code>-p</code> 或者 <code>-P</code> 参数用来设置对外暴露端口。使用 <code>-P</code> 选项，Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口。 <code>-p</code> 可以设置本地端口和容器端口的映射规则（ <code>-p 5000:5000</code> ），如果使用两个冒号 <code>::</code> 会将绑定任意端口到容器的端口（ <code>-p 127.0.0.1::5000</code> ），本地则会自动分配。而且 <code>-p</code> 允许使用多次绑定多个端口。
</p>

<ul class="org-ul">
<li><code>docker container ls</code> 或者 <code>docker ps -a</code> 可以看到容器对外暴露的端口。</li>
<li><code>docker port container</code> 查看当前映射的端口配置</li>
</ul>
</div>
</div>

<div id="outline-container-orgc42a95f" class="outline-3">
<h3 id="orgc42a95f"><span class="section-number-3">9.2.</span> 容器互联</h3>
<div class="outline-text-3" id="text-9-2">
<p>
推荐使用自定义 Docker 网络来连接多个容器，而不是 <code>--link</code> 参数。
</p>

<ul class="org-ul">
<li><code>docker network create -d bridge my-net</code>: 创建一个新的容器网络
<ul class="org-ul">
<li><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> 和 <code>overlay</code> ，overlay 用于 Swarm mode</li>
</ul></li>
<li><code>docker run --network my-net</code>: 运行容器并连接到新的网络，属于同一个网络下的容器是互通的， <code>ping docker-name</code></li>
</ul>
</div>
</div>

<div id="outline-container-orgdf11b1b" class="outline-3">
<h3 id="orgdf11b1b"><span class="section-number-3">9.3.</span> 配置 DNS</h3>
<div class="outline-text-3" id="text-9-3">
<p>
在容器中使用 <code>mount</code> 可以看到挂载信息：
</p>

<pre class="example">
/dev/sda1 on /etc/resolv.conf type ext4 (rw,relatime,data=ordered)
/dev/sda1 on /etc/hostname type ext4 (rw,relatime,data=ordered)
/dev/sda1 on /etc/hosts type ext4 (rw,relatime,data=ordered)
</pre>

<p>
宿主机的 DNS 信息发生变化之后，所有容器的 DNS 配置通过配置 <code>/etc/resolv.conf</code> 文件立刻得到更新。配置全部容器的 DNS，也可以在 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置（注：MacOS 下配置在 <code>Preferences &gt; Daemon &gt; Advanced</code> ，而不是配置文件）。
</p>

<pre class="example">
{
  "dns" : [
    "114.114.114.114",
    "8.8.8.8"
  ]
}
</pre>

<p>
除此之外，也可以在 <code>docker run</code> 中手动指定容器的配置：
</p>

<ul class="org-ul">
<li><code>-h HOSTNAME</code> 或者 <code>--hostname=HOSTNAME</code>: 设置容器的主机名，会被写到容器内的 <code>/etc/hostname</code> 和 <code>/etc/hosts</code> ，但它在容器外部看不到，既不会在 <code>docker container ls</code> 中显示，也不会被其它容器的 <code>/etc/hosts</code> 看到</li>
<li><code>--dns=IP_ADDRESS</code> 添加 DNS 服务器到容器的 <code>/etc/resolv.conf</code> ，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code> 中的主机名</li>
<li><code>--dns=DOMAIN</code> 设计容器的搜索域，当设定搜索域为 <code>.example.com</code> 时，在搜索名为 host 的主机时，DNS 不仅搜索 host，还会搜索 <code>host.example.com</code></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org3b30e30" class="outline-2">
<h2 id="org3b30e30"><span class="section-number-2">10.</span> 常用的镜像库</h2>
<div class="outline-text-2" id="text-10">
</div>
<div id="outline-container-orga8fafd3" class="outline-3">
<h3 id="orga8fafd3"><span class="section-number-3">10.1.</span> BusyBox</h3>
<div class="outline-text-3" id="text-10-1">
<p>
<a href="https://github.com/docker-library/busybox">BusyBox</a> 是一个很小的镜像库（几兆），集成了一百多个常用的 Linux 命令和工具，方便做快速验证和熟悉 Linux 命令，也可以用来学习 Docker 命令。
</p>
</div>
</div>

<div id="outline-container-org11bb519" class="outline-3">
<h3 id="org11bb519"><span class="section-number-3">10.2.</span> Apline Linux</h3>
<div class="outline-text-3" id="text-10-2">
<p>
<a href="https://alpinelinux.org/">Apline Linux</a> 是基于 <code>musi libc</code> 和 <code>busybox</code> 的安全至上的轻量级的 Linux 发行版，而且它提供了自己的包管理工具 <a href="https://pkgs.alpinelinux.org/packages">apk</a>。Docker 官方已经建议用 Apline 替代之前的 Ubuntu 做为基础镜像环境。
</p>

<p>
如果要使用 Apline 镜像替换 Ubuntu ，安装软件包时需要用 apk 包管理工具替换 apt。如: <code>apk add --no-cache &lt;package&gt;</code> 。
</p>
</div>
</div>
</div>

<div id="outline-container-org187d01d" class="outline-2">
<h2 id="org187d01d"><span class="section-number-2">11.</span> 实践</h2>
<div class="outline-text-2" id="text-11">
<p>
<b>不要把 Docker 当成虚拟机来用，Docker 不是虚拟机！</b>
</p>
</div>

<div id="outline-container-org2236b0b" class="outline-3">
<h3 id="org2236b0b"><span class="section-number-3">11.1.</span> ENTRYPOINT 和 CMD 的区别</h3>
<div class="outline-text-3" id="text-11-1">
<ol class="org-ol">
<li>Docker 默认的 ENTRYPOINT 是 <code>/bin/sh -c</code> ，但是没有默认的 CMD。 <span class="underline">CMD 是 ENTRYPOINT 的参数</span> ，一个 Dockerfile 只能有一个 CMD 命令，多个命令只会执行最后一个</li>
<li><p>
镜像运行时，ENTRYPOINT 命令会最先执行； <code>docker run</code> 后执行的命令会追加到 ENTRYPOINT 之后。ENTRYPOINT 会可以指定脚本：
</p>
<pre class="example">
COPY ./docker-entrypoint.sh /
ENTRYPOINT ["/docker-entrypoint.sh"]
CMD ["postgres"]
</pre></li>
<li>在运行 docker 时，添加命令会覆盖 CMD， <code>docker run rails_app rails console</code> 会覆盖默认的命令</li>
</ol>

<p>
<b>使用上的最佳实践</b>
</p>

<p>
不建议 <code>ENTRYPOINT</code> 和 <code>CMD</code> 一起使用，会增加复杂性。通过只需要 <code>CMD</code> ，只有当你需要吧容器当成一个进程来使用才使用 <code>ENTRYPOINT</code> 。
</p>

<p>
<code>ENTRYPOINT</code> 设置镜像的主要命令， <code>CMD</code> 做为默认 flag，比如：
</p>

<pre class="example">
FROM ubuntu
ENTRYPOINT ["top", "-b"]
CMD ["-c"]
</pre>

<p>
<b>语法最佳实践</b>
</p>

<p>
<code>CMD</code> 应该使用这种格式: <code>CMD ["executable", "param1", "param2", ...]</code>
</p>

<p>
<b>总结</b>
</p>

<p>
ENTRYPOINT 和 CMD 都是用来定义容器启动时所要执行的命令，下面说明两者之间的关系：
</p>

<ol class="org-ol">
<li>Dockerfile 应该至少指定一个 CMD 或者 ENTRYPOINT 命令</li>
<li>当容器做为可执行文件时，应该定义 ENTRYPOINT</li>
<li>CMD 应该做为 ENTRYPOINT 的默认参数，或在容器中执行 ad-hoc 命令</li>
<li>运行容器设置交互参数（alternative arguments）会覆盖 CMD</li>
</ol>

<p>
via: <a href="https://medium.freecodecamp.org/docker-entrypoint-cmd-dockerfile-best-practices-abc591c30e21">Docker ENTRYPOINT &amp; CMD: Dockerfile best practices</a>：ENTRYPOINT &amp; CMD
</p>
</div>
</div>

<div id="outline-container-org13f8308" class="outline-3">
<h3 id="org13f8308"><span class="section-number-3">11.2.</span> 端口暴露、-p 和 -P 的区别</h3>
<div class="outline-text-3" id="text-11-2">
<p>
有很多资料介绍 <code>EXPOSE</code> 和 <code>-p</code> 的区别，比如 <a href="https://blog.lab99.org/post/docker-2016-07-14-faq.html#zen-me-ying-she-su-zhu-duan-kou-dockerfile-zhong-de-expose-he-docker-run-p-you-sha-qu-bie">这个</a> 还有 <a href="https://stackoverflow.com/questions/22111060/what-is-the-difference-between-expose-and-publish-in-docker">这个</a>，但使用中只要注意：
</p>

<ul class="org-ul">
<li><code>EXPOSE</code> 只是设置暴露端口，主机无法访问，只是一个声明（虽然也可以在 <code>run</code> 时 <code>--expose</code> ，但是写在 Dockerfile 中比较好），通常用于写 Dockerfile 的人设定的服务暴露的端口，类似一个规范性的东西，</li>
</ul>
<p>
一般和 <code>-P</code> 选项一起使用，在命令行指定 <code>-P</code> 之后 <code>EXPOSE</code> 的端口会被随机映射到宿主机上，宿主机上的端口是动态分配的（保证不冲突）。
还因为在构建镜像的时候，你无法决定运行期主机端口如何映射到容器内部，因为你不知道运行容器的机器有哪些端口是可用的。
</p>
<ul class="org-ul">
<li><code>-p</code> 或者 <code>--publish</code> 是实际建立网络映射的方法，创建宿主机和容器的端口映射规则，比如 <code>-p 127.0.0.1:6379:6379</code> 会将容器中的 6379 映射到宿主机的 <code>127.0.0.1:6379</code> 上</li>
</ul>

<p>
再简单来讲， <code>EXPOSE</code> 只是规范（documenting）， <code>-p</code> 才是实际和网络映射有关的。
</p>
</div>
</div>

<div id="outline-container-org7e0af2b" class="outline-3">
<h3 id="org7e0af2b"><span class="section-number-3">11.3.</span> Docker 如何跟随系统启动？</h3>
<div class="outline-text-3" id="text-11-3">
<p>
启动时添加 <code>--restart=always</code> 参数。
</p>
</div>
</div>

<div id="outline-container-org321996e" class="outline-3">
<h3 id="org321996e"><span class="section-number-3">11.4.</span> 对已有的容器（重新）添加端口映射</h3>
<div class="outline-text-3" id="text-11-4">
<ol class="org-ol">
<li>stop 已运行的容器</li>
<li>commit old to new</li>
<li>run new 设置端口映射</li>
</ol>

<p>
来自：<a href="https://stackoverflow.com/questions/19335444/how-do-i-assign-a-port-mapping-to-an-existing-docker-container">How do I assign a port mapping to an existing Docker container?</a>
</p>
</div>
</div>

<div id="outline-container-org80d913f" class="outline-3">
<h3 id="org80d913f"><span class="section-number-3">11.5.</span> ADD 和 COPY 的区别</h3>
<div class="outline-text-3" id="text-11-5">
<p>
都是从上下文环境拷贝数据到镜像中，区别就是 <code>ADD</code> 比 <code>COPY</code> 做的事情更多一些。
</p>

<ul class="org-ul">
<li><code>ADD</code> 允许 <code>&lt;src&gt;</code> 是个 URL</li>
<li>如果 <code>&lt;src&gt;</code> 是个压缩格式的文件，~ADD~ 也会自动解压。</li>
</ul>

<p>
根据 <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#add-or-copy">Dockerfile</a> 最佳实践 中说明，建议使用 <code>COPY</code> 而不是 <code>ADD</code> ，除非你必须要使用 <code>ADD</code> 的特性才能完成工作。
</p>
</div>
</div>
</div>

<div id="outline-container-org5be2af6" class="outline-2">
<h2 id="org5be2af6"><span class="section-number-2">12.</span> FAQ</h2>
<div class="outline-text-2" id="text-12">
</div>
<div id="outline-container-org471b6f9" class="outline-3">
<h3 id="org471b6f9"><span class="section-number-3">12.1.</span> 如何获取机器容器 IP</h3>
<div class="outline-text-3" id="text-12-1">
<pre class="example">
docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' container_name_or_id
</pre>
</div>
</div>

<div id="outline-container-org7216ba5" class="outline-3">
<h3 id="org7216ba5"><span class="section-number-3">12.2.</span> docker 作为 crontab 命令时报错, <code>Error The input device is not a TTY</code></h3>
<div class="outline-text-3" id="text-12-2">
<p>
解决办法时去掉 docker 命令中的 <code>-t</code> 选项，参考：
</p>

<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/43099116/error-the-input-device-is-not-a-tty">Error The input device is not a TTY </a></li>
<li><a href="https://medium.com/@ismailyenigul/docker-error-in-crontab-the-input-device-is-not-a-tty-7280cc42cf19">docker error in crontab: the input device is not a TTY</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgbdc714a" class="outline-2">
<h2 id="orgbdc714a"><span class="section-number-2">13.</span> 参考资料</h2>
<div class="outline-text-2" id="text-13">
<ul class="org-ul">
<li><a href="https://yeasy.gitbooks.io/docker_practice">Docker - 从入门到实践</a>：本文主要以这本书为参考骨架，然后根据其它资料扩展</li>
<li><a href="https://blog.lab99.org/post/docker-2016-07-14-faq.html">Docker 问答录（100 问）</a></li>
</ul>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
<a href="https://github.com/microsoft/WSL/issues/6655">https://github.com/microsoft/WSL/issues/6655</a>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="postamble">First created: 2018-08-20 17:45:11 <br />Last updated: 2022-08-23 Tue 18:22 <br />Power by <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.1 (<a href="https://orgmode.org">Org</a> mode 9.5.4)</p>
</div>
</body>
</html>
